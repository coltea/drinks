<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis持久化策略</title>
    <link href="/2021/04/01/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/"/>
    <url>/2021/04/01/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis持久化策略"><a href="#Redis持久化策略" class="headerlink" title="Redis持久化策略"></a>Redis持久化策略</h1><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li> 宕机了，Redis如何避免数据丢失？</li><li> AOF 日志是如何实现的？</li><li> AOF日志过大怎么解决？</li><li> AOF 重写会阻塞吗?</li><li> 快照时数据能修改吗?</li><li> 相对比较好的持久化策略</li></ol><p>三点建议：</p><ul><li>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；</li><li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li><li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li></ul><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>RDB(内存快照): 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。</p><ul><li>相对于大数据集，RDB的启动效率会更高。</li><li>fork出一个子进程同步数据 子进程共享主进程数, 不阻塞主进程数据，主进程在修改数据时会创建副本 子进程读副本，fork创建会阻塞主进程（涉及内存共享）</li></ul><p> Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p><ul><li><strong>save</strong>：在主线程中执行，会导致阻塞；</li><li><strong>bgsave</strong>：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li></ul><p><img src="https://static001.geekbang.org/resource/image/4d/cc/4dc5fb99a1c94f70957cce1ffef419cc.jpg" alt="img"></p><p><strong>但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</strong></p><p>bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。 </p><p>为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</p><h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><p>AOF原理是将Reids的操作日志以追加的方式写入文件 。</p><ul><li><p>先处理后写，1.避免错误日志 2.不会阻塞操作，3.避免写完日志后宕机</p></li><li><p>通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性</p></li><li><p>AOF 重写不阻塞  后台子进程 bgrewriteaof处理</p></li></ul><p><img src="https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg" alt="img"></p><h4 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h4><ul><li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘； 影响性能</li><li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li><li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li></ul><h4 id="AOF工作原理"><a href="#AOF工作原理" class="headerlink" title="AOF工作原理"></a>AOF工作原理</h4><p>1、Redis 执行 fork() ，现在同时拥有父进程和子进程。<br>2、子进程开始将新 AOF 文件的内容写入到临时文件。<br>3、对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。<br>4、当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。<br>5、搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</p><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><ol><li>auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB</li><li>auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。</li></ol><p>AOF文件大小同时超出上面这两个配置项时，会触发AOF重写。</p><p><img src="https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里外包（Python）笔试题</title>
    <link href="/2021/03/29/%E9%98%BF%E9%87%8C%E5%A4%96%E5%8C%85/"/>
    <url>/2021/03/29/%E9%98%BF%E9%87%8C%E5%A4%96%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1-linux"><a href="#1-linux" class="headerlink" title="1.linux"></a>1.linux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">ll -h<br>mkdir<br>cd<br>scp<br>htop<br>iftop<br>tail -f app.log<br>vi XX.<br>lsof -i:80<br>ping<br>telnet ip port<br>yum install<br>ps -ef|grep python<br>killall &lt;PROCRESS&gt;<br>kill -9 &lt;PID&gt;<br>ssh root@&lt;HOST&gt;<br>curl &lt;&gt;<br>chmod 777 &lt;&gt;<br>ln -s &lt;&gt; &lt;&gt; <br></code></pre></td></tr></table></figure><p>cat filename.log |grep ‘login’|wc -l</p><h3 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2.SQL"></a>2.SQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select distinct name from student  where score&gt;95;<br>select count(distinct name)  from student  where score&gt;95;<br>select count(1) as ct,socre from student group by  socre order by ct desc <br></code></pre></td></tr></table></figure><h3 id="3-编码"><a href="#3-编码" class="headerlink" title="3.编码"></a>3.编码</h3><h4 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">array_insert</span>(<span class="hljs-params">array, n</span>):</span><br>    <span class="hljs-keyword">for</span> index, key <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(array):<br>        <span class="hljs-keyword">if</span> n &lt;= key:<br>            <span class="hljs-keyword">return</span> index<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(array)<br></code></pre></td></tr></table></figure><h4 id="多线程锁及通信"><a href="#多线程锁及通信" class="headerlink" title="多线程锁及通信"></a>多线程锁及通信</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">target_a</span>(<span class="hljs-params">counter=<span class="hljs-number">10</span></span>):</span><br>    <span class="hljs-keyword">while</span> counter:<br>        locka.acquire()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;a&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        lockb.release()<br>        counter -= <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">target_b</span>(<span class="hljs-params">counter=<span class="hljs-number">10</span></span>):</span><br>    <span class="hljs-keyword">while</span> counter:<br>        lockb.acquire()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;b&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        lockc.release()<br>        counter -= <span class="hljs-number">1</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">target_c</span>(<span class="hljs-params">counter=<span class="hljs-number">10</span></span>):</span><br>    <span class="hljs-keyword">while</span> counter:<br>        lockc.acquire()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;c&#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>        locka.release()<br>        counter -= <span class="hljs-number">1</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    locka = threading.Lock()<br>    lockb = threading.Lock()<br>    lockc = threading.Lock()<br><br>    lockb.acquire()<br>    lockc.acquire()<br><br>    t1 = threading.Thread(target=target_a)<br>    t2 = threading.Thread(target=target_b)<br>    t3 = threading.Thread(target=target_c)<br><br>    t1.start()<br>    t2.start()<br>    t3.start()<br></code></pre></td></tr></table></figure><h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span>(<span class="hljs-params">lt</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(lt) &lt;= <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> lt<br>    mid = lt[<span class="hljs-built_in">len</span>(lt) // <span class="hljs-number">2</span>]<br>    lt.remove(mid)<br>    left_lt, right_lt = [], []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> lt:<br>        <span class="hljs-keyword">if</span> i &lt;= mid:<br>            left_lt.append(i)<br>        <span class="hljs-keyword">if</span> i &gt; mid:<br>            right_lt.append(i)<br>    <span class="hljs-keyword">return</span> quick_sort(left_lt) + [mid] + quick_sort(right_lt)<br></code></pre></td></tr></table></figure><h4 id="找两数之和"><a href="#找两数之和" class="headerlink" title="找两数之和"></a>找两数之和</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_sum</span>(<span class="hljs-params">lt, n</span>):</span><br>    dt = &#123;i: e <span class="hljs-keyword">for</span> e, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lt) <span class="hljs-keyword">if</span> n - i &lt;= i&#125;<br>    res = []<br>    <span class="hljs-keyword">for</span> e, i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lt):<br>        <span class="hljs-keyword">if</span> n - i <span class="hljs-keyword">in</span> dt:<br>            <span class="hljs-keyword">if</span> e != dt[n - i]:<br>                res.append([n - i, i])<br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    r = find_sum([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>], <span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(r)<br></code></pre></td></tr></table></figure><h3 id="发散题"><a href="#发散题" class="headerlink" title="发散题"></a>发散题</h3><h4 id="接口耗时长-排查及优化"><a href="#接口耗时长-排查及优化" class="headerlink" title="接口耗时长-排查及优化"></a>接口耗时长-排查及优化</h4><p>time.time()打点找出运行慢的那一块代码，然后具体问题具体分析</p><h5 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理"></a>问题处理</h5><ul><li><p><strong>代码bug</strong>: 修bug</p></li><li><p><strong>多个IO请求等待:</strong> 开多线程池请求</p></li><li><p><strong>cpu密集型计算：</strong> 考虑开多进程处理或者c++重写 py调用</p></li><li><p><strong>数据库查询慢:</strong></p><ul><li><p>用explain 看走没走索引 没有的话 对应字段 建索引 force index 强制走索引查询</p></li><li><p>数据库内存 cpu压力不正常 查看占用高的sql 优化 或者升级 </p></li><li><p>查看show processlist 查看是不是有过多或者慢查询占用内存和cpu 再kill</p></li><li><p> ddl语句锁表表结构重构中导致不能查询 </p></li><li><p>sql语句优化 减少like join表  !=，乱建索引，select *</p></li></ul></li></ul><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><ul><li>消息队列 与接口返回无关的一系列操作可以考虑异步 redis或者mq消息队列处理，单生产者接入多消费者</li><li>redis加缓存 </li></ul><h4 id="Url请求返回"><a href="#Url请求返回" class="headerlink" title="Url请求返回"></a>Url请求返回</h4><ol><li>url解析成ip : /etc/hosts + DNS</li><li>网络层 ip协议 arp协议 mac地址查询</li><li>传输层 TCP 连接：TCP 三次握手</li><li>应用层 HTTP 连接: 发送 HTTP 请求</li><li>服务器监听对应端口 处理请求</li><li>nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口</li><li>k8s、docker监听端口处理</li><li>python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn</li><li>框架处理（flask/django/fastapi）解析http报文 json/text/file返回</li><li>查询redis缓存/mysql</li><li>组装数据并返回 HTTP 报文</li><li>浏览器解析渲染页面/前端直接处理的json/xml数据</li><li>断开连接：TCP 四次挥手</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python</title>
    <link href="/2021/03/27/backend/Python/"/>
    <url>/2021/03/27/backend/Python/</url>
    
    <content type="html"><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h4 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程/线程/协程"></a>进程/线程/协程</h4><p>进程下的多个线程可以共享该进程的所有资源，进程之间相互独立</p><ul><li><strong>多进程</strong>:cpu密集走进程,进程资源开销大，但相对稳定</li><li>**多线程:**io密集走线程,python 有gil多线程只能发挥单核的性能 </li></ul><p>在CPU密集的程序中，线程有点鸡肋，无法发挥多处理器的效率，这一点可以用进程来做。</p><p>在IO 密集的程序中，大量时间都花在等待IO上，对CPU不敏感，线程可以很好的胜任。</p><h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><h4 id="一、对象的引用计数机制"><a href="#一、对象的引用计数机制" class="headerlink" title="一、对象的引用计数机制"></a>一、对象的引用计数机制</h4><p>Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。</p><p>引用计数增加的情况：</p><p>1，一个对象分配一个新名称</p><p>2，将其放入一个容器中（如列表、元组或字典）</p><p>引用计数减少的情况：</p><p>1，使用del语句对对象别名显示的销毁</p><p>2，引用超出作用域或被重新赋值</p><h4 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h4><p>1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。</p><p>2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。</p><h4 id="三、内存池机制"><a href="#三、内存池机制" class="headerlink" title="三、内存池机制"></a>三、内存池机制</h4><p>Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。</p><p>1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。</p><h4 id="with底层实现"><a href="#with底层实现" class="headerlink" title="with底层实现"></a>with底层实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">__inter和 __end 方法<br></code></pre></td></tr></table></figure><h4 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h4><p>​    相当于类的父类 用于创建类。python所以的东西都是对象，都是从一个类里面创建出来的，type就是python的内建元类。</p><h3 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h3><p>​    异步非阻塞，内部可以await 停止做其他的操作比如网络</p><p>​    </p><p>Type Hint</p><p>​    有提示</p><h4 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h4><ul><li>约定俗成、不是强制</li></ul><h4 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h4><p>​    分cpu密集型还是网络密集型的程序</p><ul><li>分本身考虑sql</li><li>接口 异步 协成</li><li>cpu换成c或者考虑多进程、pypy</li></ul><h4 id="魔术方法（Magic-Method）"><a href="#魔术方法（Magic-Method）" class="headerlink" title="魔术方法（Magic Method）"></a>魔术方法（Magic Method）</h4><h4 id="init-new"><a href="#init-new" class="headerlink" title="__init__ / __new__"></a><code>__init__ / __new__</code></h4><ol><li>init是初始化方法 实例方法，new是构造方法 静态方法</li><li>new在init之前执行, 用于创建对象并返回对象（可返回实例如不可变对象）</li><li>init返回None、new返回对象或者实例</li><li>绝大多数情况下，我们都不需要自己重写__new__方法，但在当继承一个不可变的类型（例如str类,int类等）时，则需要用到new。</li></ol><h4 id="getter-setter"><a href="#getter-setter" class="headerlink" title="__getter__ / __setter__"></a><code>__getter__ / __setter__</code></h4><h4 id="doc"><a href="#doc" class="headerlink" title="__doc__"></a><code>__doc__</code></h4><p>文档字符串</p><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>抽离出大量函数中与函数功能本身无关的雷同代码并继续重用</p><ul><li>日志</li><li>资源开销型 with外写</li></ul><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p><a href="https://docs.python.org/zh-cn/3/glossary.html#term-generator">Generator</a> 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield"><code>yield</code></a> 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">g = (x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br></code></pre></td></tr></table></figure><h3 id="迭代器-iter"><a href="#迭代器-iter" class="headerlink" title="迭代器 iter()"></a>迭代器 iter()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>a<br>&lt;list_iterator <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10abbac50</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>a.__next__()<br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.__next__()<br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>搜索从父类所继承属性的操作是深度优先、从左至右、递归查找。 派生类方法覆盖重载基类</p><h4 id="metaclass"><a href="#metaclass" class="headerlink" title="metaclass"></a>metaclass</h4><p>元类 orm用的</p><h4 id="Classmethod-staticmethod"><a href="#Classmethod-staticmethod" class="headerlink" title="Classmethod / staticmethod"></a>Classmethod / staticmethod</h4><p>​        <strong>相同</strong></p><ul><li><p>都不需要实例化，即可调用</p></li><li><p>类方法需要cls参数传入，静态函数则不用</p><p><strong>区别</strong></p></li><li><p>类函数可以当做作为类似<code>__new__</code>一样的构造函数，用来返回类对象</p></li></ul><h4 id="args-kwargs"><a href="#args-kwargs" class="headerlink" title="args/kwargs"></a>args/kwargs</h4><p>args 不定数量的输入参数</p><p>kwargs 不定数量的键值对输入参数</p><p><code>*args</code>必须在<code>**kwargs</code>前面</p><h1 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h1><p>web server如何与web application通信的规范</p><p>其实就是一个规范，他规范了Python程序和服务器之间的通信。对于Apache/Nginx等等服务器来说，只要支持WSGI规范，就可以保证所有(兼容WSGI的)Python程序能运行；对于Python程序或者框架来说，只要兼容WSGI，就可以保证能在所有(支持WSGI的)服务器上运行。这是WSGI的重要性，而那篇文章则是更深入的探讨了WSGI的设计，以及有没有什么可以提升的地方。</p><p>一个HTTP请求的过程可以分为两个阶段，第一阶段是从客户端到WSGI Server，第二阶段是从WSGI Server 到WSGI Application</p><p><strong>1、两级结构</strong> 在这种结构里，uWSGI作为服务器，它用到了HTTP协议以及wsgi协议，flask应用作为application，实现了wsgi协议。当有客户端发来请求，uWSGI接受请求，调用flask app得到相应，之后相应给客户端。 这里说一点，通常来说，Flask等web框架会自己附带一个wsgi服务器(这就是flask应用可以直接启动的原因)，但是这只是在开发阶段用到的，在生产环境是不够用的，所以用到了uwsgi这个性能高的wsgi服务器。</p><p><strong>2、三级结构</strong> 这种结构里，uWSGI作为中间件，它用到了uwsgi协议(与nginx通信)，wsgi协议(调用Flask app)。当有客户端发来请求，nginx先做处理(静态资源是nginx的强项)，无法处理的请求(uWSGI)，最后的相应也是nginx回复给客户端的。 多了一层反向代理有什么好处？</p><p>提高web server性能(uWSGI处理静态资源不如nginx；nginx会在收到一个完整的http请求后再转发给wWSGI)</p><p>nginx可以做负载均衡(前提是有多个服务器)，保护了实际的web服务器(客户端是和nginx交互而不是uWSGI)</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2021/03/27/backend/MySQL/"/>
    <url>/2021/03/27/backend/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 从不订购的客户<br>select a.Name as Customers  from Customers  a<br>left join Orders b on a.Id&#x3D;b.CustomerId <br>Where b.Id is null <br><br>select a.Name as &#96;Customers&#96;  from Customers  a<br>where id not in (select distinct CustomerId from Orders)<br><br><br># 总分前三的学生姓名<br>SELECT &#96;name&#96; from (<br>  SELECT b.&#96;name&#96;,SUM(a.score)<br>  from score a <br>  join student b on a.student_id&#x3D;b.id<br>  GROUP BY  b.&#96;name&#96;<br>  ORDER BY SUM(a.score) desc limit 3<br>) as t<br><br><br># 每门课成绩前五名<br>SELECT a.class,a.&#96;name&#96;,a.score from grade a <br>WHERE (SELECT COUNT(1) from grade b WHERE a.class&#x3D;b.class and  a.score &lt;b.score)&lt;5<br>ORDER BY class,score desc<br><br><br>SELECT a.class,a.&#96;name&#96;,a.score ,COUNT(b.score) as &quot;No&quot;   from grade a <br>left join  grade b on a.class&#x3D;b.class and a.score&lt; b.score<br>GROUP BY a.class,a.&#96;name&#96;,a.score<br>HAVING COUNT(b.score) &lt;5<br>ORDER BY a.class,a.score desc<br><br><br><br># 获取所有部门中当前员工薪水最高的相关信息<br>select r.dept_no,ss.emp_no,r.maxSalary from (<br>  select d.dept_no,max(s.salary)as maxSalary from dept_emp d,salaries s<br>  where d.emp_no&#x3D;s.emp_no<br>  group by d.dept_no<br>)as r,salaries ss,dept_emp dd<br>where r.maxSalary&#x3D;ss.salary and r.dept_no&#x3D;dd.dept_no and dd.emp_no&#x3D;ss.emp_no<br>order by r.dept_no asc<br><br><br><br><br></code></pre></td></tr></table></figure><blockquote><h4 id="为什么用id做主键？"><a href="#为什么用id做主键？" class="headerlink" title="为什么用id做主键？"></a><strong>为什么用id做主键</strong>？</h4></blockquote><ol><li>行内约定规范（例如阿里官方的java开发手册 id、create_time、update_time 是表的必备字段，其中id为主键）</li><li>可以唯一标识一行，</li><li>数据自增 id 是顺序的，可以保证索引树上的数据比较紧凑，有更高的空间利用率以及减少数据页的分裂合并等操作，提高效率。</li><li>空间占用相对较少 整型做主键，则只要4个字节 利于回表：先在二级索引查询到对应的主键值，然后根据主键再去聚簇索引里面取查询。其他的唯一索引例如手机号、身份证号作为主键等可能比较长 32</li></ol><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p><p>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p><ul><li><p>原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p></li><li><p>一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p></li><li><p>隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</p></li><li><p>持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p></li><li><p>【<strong>脏读</strong>】读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</p></li><li><p>【<strong>不可重复读</strong>】读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</p></li><li><p>【幻读】可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p></li><li><p>可串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p></li></ul><p>不可重复读指的是数据修改、幻读指的是数据增加不涉及修改</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p><p>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。</p>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2021/03/27/backend/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/03/27/backend/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h3><p>​    硬件进行抽象和管理，对应用进行服务和管理</p><h3 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h3><ul><li><p><strong>进程</strong>：资源分配的基本单位，执行程序的实例。</p></li><li><p><strong>线程：</strong>cpu调度的基本单元，同进程下的线程共享资源。</p></li><li><p><strong>协程：</strong>协程是一种用户态的轻量级线程，协程程序主动控制切换，没有切换的开销，所以执行效率极高，。</p></li></ul><ul><li><strong>并发:</strong></li><li><strong>并行:</strong></li></ul><ul><li>微观上只有一个核心只能同时执行一个进程，</li><li>线程与同属一个进程的其他的<strong>线程共享</strong>进程所拥有的全部资源</li></ul><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>​        新生、预备、阻塞、运行、终止</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ol><li>管道( pipe )：<br>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li><li>有名管道 (namedpipe) ：<br>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li><li>信号量(semophore ) ：<br>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li>消息队列( messagequeue ) ：<br>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li>信号 (sinal ) ：<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li><li>共享内存(shared memory ) ：<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li><li>套接字(socket ) ：<br>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</li></ol><p>​    </p><p>双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输</p><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ol><li>锁机制：包括互斥锁、条件变量、读写锁<br>互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li><li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li><li>信号机制(Signal)：类似进程间的信号处理<br>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</li></ol><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>​    多个线程竞争有限数量的资源，自己持有某种资源又等待其他资源释放，一直在保持这种状态，称为死锁。</p><p>​    </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2021/03/27/backend/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/03/27/backend/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h3 id="url解析返回"><a href="#url解析返回" class="headerlink" title="url解析返回"></a>url解析返回</h3><ol><li><p>ip解析:缓存(浏览器和操作系统)-/etc/hosts-根域名-顶级域名-权威(二级)域名</p></li><li><p>网络层 ip协议 arp协议 mac地址查询</p></li><li><p>传输层 TCP 连接：TCP 三次握手</p></li><li><p>应用层 HTTP 连接: 发送 HTTP 请求</p></li><li><p>cdn直接返回/非cdn服务器监听对应端口 处理请求</p></li><li><p>七层nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口</p></li><li><p>k8s、docker监听端口处理</p></li><li><p>python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn</p></li><li><p>框架处理（flask/django/fastapi）解析http报文 </p></li><li><p>查询redis缓存/mysql</p></li><li><p>组装数据并返回 HTTP 报文 json/text/file返回</p></li><li><p>浏览器解析渲染页面/前端直接处理的json/xml数据</p></li><li><p>断开连接：TCP 四次挥手</p></li></ol><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>1.host里面找ip没有从dns里面找</p><p>2.请求ip地址 建立连接、nginx静态模板-&gt;WSGI服务器 gunicorn -&gt;flask web application -&gt; 返回</p><ul><li><strong>应用层</strong> FTP、DNS、Telnet、SMTP、HTTP</li><li>表示层  数据压缩，数据加密以及数据描述</li><li>会话层   DNS</li><li><strong>传输层</strong> tcp、udp</li><li><strong>网络层</strong> ip、ARP</li><li><strong>数据链路层</strong> PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） </li><li><strong>物理层</strong> IEEE   （中继器，集线器，网关）</li></ul><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p><strong>即地址解析协议（Address Resolution Protocol）， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址</strong>。</p><p>基于功能来考虑，ARP是链路层协议；基于分层/包封装来考虑，ARP是网络层协议。</p><h3 id="Rpc-http区别"><a href="#Rpc-http区别" class="headerlink" title="Rpc/http区别"></a>Rpc/http区别</h3><p><strong>http</strong>:<strong>有用信息占比少</strong>，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是<strong>效率低</strong>，还是因为第七层的缘故.</p><p>基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h3 id="Tcp-三次握手"><a href="#Tcp-三次握手" class="headerlink" title="Tcp 三次握手"></a>Tcp <strong>三次握手</strong></h3><p>其中ACK报文是用来应答的，SYN报文是用来同步的</p><p><strong>作用</strong>：确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</p><p>第一次、第二次不携带数据，防止恶意攻击</p><p> 第一次握手：<a href="">客户端</a>发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； </p><p> 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； </p><p> 第三次握手：<a href="">客户端</a>收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，<a href="">客户端</a>和服务器进入ESTABLISHED状态，完成三次握手。 </p><p> 握手过程中传送的包里不包含数据，三次握手完毕后，<a href="">客户端</a>与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 </p><h3 id="Tcp四次挥手"><a href="#Tcp四次挥手" class="headerlink" title="Tcp四次挥手"></a>Tcp四次挥手</h3><p> 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。 </p><p> 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 </p><p> 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br> 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。<br> 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p> 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。 </p><p> 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。 </p><p> 交换机被广泛应用于二层网络交换，俗称“二层交换机”。 </p><p> 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。 </p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p> <strong>路由器</strong>（<strong>Router</strong>）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 </p><p> <strong>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</strong> 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 </p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p> <strong>网关</strong>（Gateway），<strong>网关</strong>顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 </p><p> 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。 </p><p> 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 </p><p> <strong>网关</strong>是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过<strong>网关</strong>还原成模拟的电话信号，最后才能在电话机上听到。 </p><p> 对于以太网中的<strong>网关</strong>只能转发三层以上数据包，这一点和路由是一样的。而不同的是<strong>网关</strong>中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p>]]></content>
    
    
    <categories>
      
      <category>ComputerScience</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis面试题</title>
    <link href="/2021/03/24/backend/Redis/"/>
    <url>/2021/03/24/backend/Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h4 id="概述特性"><a href="#概述特性" class="headerlink" title="概述特性"></a>概述特性</h4><ul><li><blockquote><p><strong>Redis为什么这么快？</strong></p></blockquote><ol><li>Redis是单线程的，避免了多线程的上下文切换和并发控制开销；</li><li>Redis大部分操作时基于内存，读写数据不需要磁盘I/O，所以速度非常快；</li><li>Redis采用了I/O多路复用机制，提高了网络I/O并发性；</li><li>Redis提供高效的数据结构，如跳跃表 o(logn) 、哈希表 o(1)等；</li></ol></li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li><p><strong>String</strong> : 缓存、计数器、限速器、分布式锁、集群共享信息通用配置</p></li><li><p><strong>List</strong> : 消息队列、底层双向链表</p></li><li><p><strong>Set</strong> : 好友关系</p></li><li><p><strong>zset(SortSet)</strong> :排行榜</p></li><li><p><strong>Hash</strong> : </p></li><li><p><strong>Streams(流)</strong> :</p></li></ul><p><img src="https://static001.geekbang.org/resource/image/fb/f0/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg" alt="img"></p><h4 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h4><ul><li><p><strong>缓存</strong> string</p></li><li><p><strong>计数器</strong> string</p></li><li><p><strong>排行榜</strong>  Zset</p></li><li><p><strong>异步消息队列</strong> List</p></li><li><p><strong>分布式锁</strong> string  EX seconds | PX milliseconds</p></li><li><p><strong>共享信息、高频访问信息</strong> 如session</p></li><li><p><strong>集合关系</strong> 好友关系  Set</p></li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SET key value [EX seconds | PX milliseconds]  [NX]<br></code></pre></td></tr></table></figure><p>分布式锁是由共享存储系统(redis就是其中一种)维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作</p><ul><li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li><li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；</li><li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。</li></ul><h4 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h4><ul><li><p><strong>RDB</strong>: 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。</p><p>相对于大数据集，RDB的启动效率会更高。</p></li><li><p><strong>AOF</strong>: 原理是将Reids的操作日志以追加的方式写入文件。</p><p>通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性</p></li></ul><h4 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a><strong>架构模式</strong></h4><ul><li><p><strong>主从</strong></p><p>1对多，非高可用性</p></li><li><p><strong>哨兵</strong></p><p>监控从切换成主数据库，浪费资源</p></li><li><p><strong>集群</strong></p><p>分布式存储，至少需要三主三从</p></li></ul><h4 id="数据淘汰机制"><a href="#数据淘汰机制" class="headerlink" title="数据淘汰机制"></a>数据淘汰机制</h4><ul><li>volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li>volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li>volatile-random 从已设置过期时间的数据集中任意选择数据淘汰</li><li>allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰</li><li>allkeys-random 从所有数据集中任意选择数据进行淘汰</li><li>noeviction 禁止驱逐数据</li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li><strong>穿透</strong>:空值设置一个较短的缓存</li><li><strong>击穿</strong>(业务狭隘):热门缓存失效</li><li><strong>雪崩</strong>:短时间内缓存大量失效  时间后加随机值</li></ul><h3 id="缓存-1"><a href="#缓存-1" class="headerlink" title="缓存"></a>缓存</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>概念：</strong>当用户使用一个不存在的key进行查询时，缓存（redis）无法命中，需要访问数据库查询该数据，若数据库中没有数据，则不写入缓存（redis）中，这将导致不存在的数据每次请求都要去数据库查询，造成缓存穿透。</p><p><strong>解决办法：</strong></p><ol><li>使用布隆过滤器，通过bloomfilter.mightContain(key)来判断当前key是否命中。布隆过滤器原理：<a href="https://zhuanlan.zhihu.com/p/43263751">https://zhuanlan.zhihu.com/p/43263751</a></li><li>当数据库查询结果为空时，在redis中将key对应的value设置空值，并设置一个较短的过期时间。</li></ol><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存在同一时间内大量·键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。</p><p>解决方案：</p><p>1、也是像解决缓存穿透一样加锁排队，实现同上;</p><p>2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
