{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/debouncer.js","path":"js/debouncer.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Redis.md","hash":"1ab2a6e6ffd4953dcfecdb616b7ca69de1a76cee","modified":1616591092762},{"_id":"source/about/index.md","hash":"6fc6bf25e065856e416491ecd604d952b1e419cd","modified":1616590028373},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1616487480337},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"523b9db3801ca892124502c17d72864457cc4b21","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"76ce07d568c76fe1af640819812b82cececff0d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"dc82b6be72c786721a2f5e2acc10a2a94995c540","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"9c61bff02a011245218c2413cb32dd0e1ced2d17","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"e25ea9aad97ecb8f9b69bd79834145ddb612f018","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6cbd88a2ef9dd2198d72ccc1899c4966ac5f49f9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"27e4753464c3e8960d308969acfe696eeeeb3c71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"9d6ff8772bf54d7458ae4e846e5a2d1f2921b8a7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"d4d3c31954a6292f0ff33cbd6362e264f7622841","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"678f32403e968b6539d089a51976b8094848122e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"bccd7961fa146dd5f0d70f77e7ab94e9f58d5bd3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"8723aa57f61134a2c1dc84cc7ea88ea366f4fda3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"6ec30a9dd56341590af07f4227324f619025c109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"cdcb607f1104543a42beda647f3c9cf0f3d11623","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"39e63b3e1502803c9e8ea0c44ea662a7bbe15744","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"248ecd01aead6e07ac1904a7b7c45395a922bcc7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"70490c67b7313ae305d39331238232fe62f094f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"3e0fa1731b6e54dbcf52ccf8e200e83dc4549bfa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"0e16b5f02dbac31f400c91531d19906a5b03b181","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"eb5335379affabd4cc98b56a971df5b82cb2ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"569642bb89610c3c0f1827b1b6dff90571ec4879","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"61e9555f99edcb23d55361c7154e23af33153ecb","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"8735039ddb22a92fd1fc24771da6a86061fc16e9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"7d7444387e549e06a4a378706df92558de62e4e7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"b05933102e2047ffb7a5fdd8850a453e997693cf","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"4701f49b3dc62939adff5cc11f6d21963df7f135","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"702cd88097274924971292c042ae4955999c3a4b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"56d32eb6a00fb8421e2cff9dcdbd6071a6c8f2a0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"e3ec74fa7c7725dbf994ff2ee54f1c230d845f5d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"d4af33f8283239dbcb066dfc6ea387851274d467","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"2395fbea76dd4085e74a2e1fc6a69eea02a64949","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"fdeef91e6efc0526e612515f29f5eedc4f6a002f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"f26d8a02b78740fb3157fd96ceb29aae107108a3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"268947d8baf6b1f98dca682014adae9809f86efa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"899dacacd40044850048c3495aff3616be26408b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"854c5cf0f5b3342cac81319a0c9ba42ab698ed01","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"fec6a99eadbc596c53f530a24a03b655c021b2c2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"aada9c7363d1e553890425c6e737de7f41e54fdc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/local-search.ejs","hash":"c8b29cf71176a2f36b5b06a4befdbd405c42fbd6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ab71df2e56b60e8e193ff827e81704e5b358a977","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"d6f4ecb8a965ad86295f211081e7bb6c00af7737","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"a2d08e3b9f98b6371b2e64d664f079c99571494b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7657fa63ebff9edf789c59c59ca1426c677fbbc1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/version.js","hash":"0f179d3fe50dac444b027ed6bbe449ecea3c4f72","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"26d29403d8ecb0b533e63bde3ca73b2c91f171ff","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"d780c5ce2b04b61bad0aa0589a0f5513c9f5e9c0","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4c6fffc6d4a3b8830931800ee7da99dccf1be36e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"f6d0d4b07dfce959fe6ba41a623df89c84f910f9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"766fcf017deb4c8b0c260ac4c8d2e3489407ad89","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"24e8e9552ab7e06386912ec39351367a8a62f3b1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"35539a1ce8476e75515015a06d01ec66e4af6834","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"ad41fe6e38a61856018021a8a9865f9fa1122bfc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"source/_posts/backend/Redis.md","hash":"3dd94df41ce7dbecce81f6be533fd4db530cc70b","modified":1617266910673},{"_id":"public/content.json","hash":"e2d51010961a0dd58718baecbc65ea089d4e1454","modified":1617266928513},{"_id":"public/local-search.xml","hash":"e096bf8110d8b5cc9c3aabec5ee28b84078df6ca","modified":1617266928513},{"_id":"public/about/index.html","hash":"83cb1be22296969fa7770a1ac21f0e7ce1c1c948","modified":1616859099514},{"_id":"public/index.html","hash":"8711e87f601e3dbbc78f487205c54652d1d738c3","modified":1617266928513},{"_id":"public/categories/backend/index.html","hash":"015b86de4428aeda4d9066ec9add2297eae30ac6","modified":1616729750169},{"_id":"public/archives/index.html","hash":"f45294b4f9c612a73f9e6baf18307f2ea55eaa97","modified":1617266928513},{"_id":"public/archives/2021/index.html","hash":"f45294b4f9c612a73f9e6baf18307f2ea55eaa97","modified":1617266928513},{"_id":"public/archives/2021/03/index.html","hash":"64aa7304b927162a8b3fb539f21c00550d9cc4a1","modified":1617266928513},{"_id":"public/tags/NoSQL/index.html","hash":"03c3a6b624bc13a94123509da18316dd1ed96c30","modified":1617266928513},{"_id":"public/404.html","hash":"ba29ba6a28d0efb12c15bb9240990fd09cb39994","modified":1616859099514},{"_id":"public/tags/index.html","hash":"5e0fc4fd55b9a8e20cd6f844663aff73a600083f","modified":1617266928513},{"_id":"public/categories/index.html","hash":"6619d12e166324b9191a720517304a32580c8935","modified":1617266928513},{"_id":"public/links/index.html","hash":"5fce8ba70ff245b7f8999c4f57deb46b0929f567","modified":1616859099514},{"_id":"public/2021/03/24/backend/Redis/index.html","hash":"7ffed8973c2f667332db30ca53590cfb0c18b7a4","modified":1617266928513},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1616729750169},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1616729750169},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1616729750169},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1616729750169},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1616729750169},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1616729750169},{"_id":"public/js/boot.js","hash":"8735039ddb22a92fd1fc24771da6a86061fc16e9","modified":1616729750169},{"_id":"public/js/debouncer.js","hash":"045f324777bdfb99d4c17b1806169f029f897a65","modified":1616729750169},{"_id":"public/js/events.js","hash":"b05933102e2047ffb7a5fdd8850a453e997693cf","modified":1616729750169},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1616729750169},{"_id":"public/js/leancloud.js","hash":"4701f49b3dc62939adff5cc11f6d21963df7f135","modified":1616729750169},{"_id":"public/js/color-schema.js","hash":"7d7444387e549e06a4a378706df92558de62e4e7","modified":1616729750169},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1616729750169},{"_id":"public/js/local-search.js","hash":"702cd88097274924971292c042ae4955999c3a4b","modified":1616729750169},{"_id":"public/js/utils.js","hash":"e3ec74fa7c7725dbf994ff2ee54f1c230d845f5d","modified":1616729750169},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1616729750169},{"_id":"public/js/plugins.js","hash":"56d32eb6a00fb8421e2cff9dcdbd6071a6c8f2a0","modified":1616729750169},{"_id":"public/css/main.css","hash":"3d1e58592d3ae48e1d9505ad2e08ac510cd99dd0","modified":1616729750169},{"_id":"source/_posts/backend/MySQL.md","hash":"c9a3648c0efc5d01199a4ad88704d784a92ec7b3","modified":1616858179623},{"_id":"public/categories/Database/index.html","hash":"f0a7163694ccb8e1e8f22d956220e934042cc753","modified":1617266928513},{"_id":"public/tags/Database/index.html","hash":"27436112f03b501a61f0a30ae3461caed94e3d5b","modified":1617266928513},{"_id":"public/2021/03/27/backend/MySQL/index.html","hash":"a3cecaeeefb90f6fb1ee1d0f8c2554ee3d28492a","modified":1616859099514},{"_id":"source/_posts/backend/Python.md","hash":"8da019cbf337d1ced4baa6c47cb7e9992032f496","modified":1616858777598},{"_id":"source/_posts/backend/操作系统.md","hash":"9c3d4a11b1e016a28d009962c771853d3f34f466","modified":1616858883024},{"_id":"source/_posts/backend/计算机网络.md","hash":"7dd0a9231713e25130657a37e1f6f5210acd89fb","modified":1616858883028},{"_id":"public/categories/Python/index.html","hash":"4ac7a7e69f42b63c85b86abae361e79f56473ed7","modified":1616859099514},{"_id":"public/categories/ComputerScience/index.html","hash":"5c13ce474ae65befe9d4f6330c36aa35fb234fa5","modified":1616859099514},{"_id":"public/tags/Python/index.html","hash":"11c3c2d60fc5c199a83f3bfa5c8202571bfa15b0","modified":1617266928513},{"_id":"public/tags/CS/index.html","hash":"2e1f3cfb196a83c5c1bd88aadfed9a3009623512","modified":1616859099514},{"_id":"public/2021/03/27/backend/Python/index.html","hash":"76e767b6ba6a847000653a38678ae594f0b7d42c","modified":1617266928513},{"_id":"public/2021/03/27/backend/操作系统/index.html","hash":"27b6b6d26b0c0012a92a16ababf7b4cc54396fb5","modified":1616859099514},{"_id":"public/2021/03/27/backend/计算机网络/index.html","hash":"1568cd0480e1f4de745d5dd724e7d0024c56ea53","modified":1617266928513},{"_id":"source/_posts/阿里外包.md","hash":"f29b0ca8a95b400e75935eee38cf1d184bdef03f","modified":1616984881925},{"_id":"public/categories/面试/index.html","hash":"a99c968a1ff8f583bc58b72d1f9671e87555f33d","modified":1617266928513},{"_id":"public/tags/面试/index.html","hash":"9bccc52f02903110212bb9d8511ccbe05a7f497b","modified":1617266928513},{"_id":"public/2021/03/29/阿里外包/index.html","hash":"080d519dc5637e23c9c60c060738dd8a5e9df198","modified":1617266928513},{"_id":"source/_posts/redis/Redis持久化策略.md","hash":"0fb6d82a12ffca6b476018974a377b19eae58c9b","modified":1617266910678},{"_id":"public/categories/Redis/index.html","hash":"93582f305ba8274e2ea65d08069886ddd45ba3c1","modified":1617266928513},{"_id":"public/archives/2021/04/index.html","hash":"30e709bc2be96a21e7ca16cfdb051e2b6732fa9a","modified":1617266928513},{"_id":"public/2021/04/01/redis/Redis持久化策略/index.html","hash":"c17acfec882a8ce11237afca12e5843cb3d2ef5b","modified":1617266928513}],"Category":[{"name":"backend","_id":"ckmngk90i000319s64et590wn"},{"name":"Database","_id":"ckmrvj8ka0001g282g55f44c2"},{"name":"operating system","_id":"ckmrvx8cc0002pw82cveu4rve"},{"name":"Python","_id":"ckmrvyxld0005pw82f70yegvt"},{"name":"ComputerScience","_id":"ckmrw16x5000cpw82brda3ydf"},{"name":"面试","_id":"ckmtyu7ke0001tf8200yghr86"},{"name":"Redis","_id":"ckmymz1hc0001its685gagi37"}],"Data":[],"Page":[{"title":"about","date":"2021-03-24T12:46:46.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-03-24 20:46:46\nlayout: about\n---\n","updated":"2021-03-24T12:47:08.373Z","path":"about/index.html","comments":1,"_id":"ckmng4jca000119s6g68pccjr","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Redis面试题","date":"2021-03-24T03:49:11.000Z","_content":"# Redis\n\n#### 概述特性\n\n- > **Redis为什么这么快？**\n\n  1. Redis是单线程的，避免了多线程的上下文切换和并发控制开销；\n  2. Redis大部分操作时基于内存，读写数据不需要磁盘I/O，所以速度非常快；\n  3. Redis采用了I/O多路复用机制，提高了网络I/O并发性；\n  4. Redis提供高效的数据结构，如跳跃表 o(logn) 、哈希表 o(1)等；\n\n\n\n#### 数据结构\n\n- **String** : 缓存、计数器、限速器、分布式锁、集群共享信息通用配置\n\n- **List** : 消息队列、底层双向链表\n\n- **Set** : 好友关系\n\n- **zset(SortSet)** :排行榜\n\n- **Hash** : \n\n- **Streams(流)** :\n\n![img](https://static001.geekbang.org/resource/image/fb/f0/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg)\n\n\n\n#### 业务场景\n\n- **缓存** string\n\n- **计数器** string\n\n- **排行榜**  Zset\n\n- **异步消息队列** List\n\n- **分布式锁** string  EX seconds | PX milliseconds\n\n- **共享信息、高频访问信息** 如session\n\n- **集合关系** 好友关系  Set\n\n  \n\n#### 分布式锁\n\n```shell\nSET key value [EX seconds | PX milliseconds]  [NX]\n```\n\n分布式锁是由共享存储系统(redis就是其中一种)维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作\n\n- 加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；\n- 锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；\n- 锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。\n\n\n\n#### 持久化策略\n\n- **RDB**: 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。\n\n  相对于大数据集，RDB的启动效率会更高。\n\n- **AOF**: 原理是将Reids的操作日志以追加的方式写入文件。\n\n  通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性\n\n\n\n#### **架构模式**\n\n- **主从**\n\n  1对多，非高可用性\n\n- **哨兵**\n\n  监控从切换成主数据库，浪费资源\n\n- **集群**\n\n  分布式存储，至少需要三主三从\n\n\n\n#### 数据淘汰机制\n\n- volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰\n- volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰\n- volatile-random 从已设置过期时间的数据集中任意选择数据淘汰\n- allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰\n- allkeys-random 从所有数据集中任意选择数据进行淘汰\n- noeviction 禁止驱逐数据\n\n\n\n#### 缓存\n\n- **穿透**:空值设置一个较短的缓存\n- **击穿**(业务狭隘):热门缓存失效\n- **雪崩**:短时间内缓存大量失效  时间后加随机值\n\n\n\n### 缓存\n\n#### 缓存穿透\n\n**概念：**当用户使用一个不存在的key进行查询时，缓存（redis）无法命中，需要访问数据库查询该数据，若数据库中没有数据，则不写入缓存（redis）中，这将导致不存在的数据每次请求都要去数据库查询，造成缓存穿透。\n\n**解决办法：**\n\n1. 使用布隆过滤器，通过bloomfilter.mightContain(key)来判断当前key是否命中。布隆过滤器原理：https://zhuanlan.zhihu.com/p/43263751\n2. 当数据库查询结果为空时，在redis中将key对应的value设置空值，并设置一个较短的过期时间。\n\n\n\n\n\n#### 缓存雪崩\n\n缓存在同一时间内大量·键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。\n\n解决方案：\n\n1、也是像解决缓存穿透一样加锁排队，实现同上;\n\n2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;","source":"_posts/backend/Redis.md","raw":"---\ntitle: Redis面试题\ndate: 2021-03-24 11:49:11\ntags: \n - Database\n - NoSQL\ncategories: \n - Redis\n---\n# Redis\n\n#### 概述特性\n\n- > **Redis为什么这么快？**\n\n  1. Redis是单线程的，避免了多线程的上下文切换和并发控制开销；\n  2. Redis大部分操作时基于内存，读写数据不需要磁盘I/O，所以速度非常快；\n  3. Redis采用了I/O多路复用机制，提高了网络I/O并发性；\n  4. Redis提供高效的数据结构，如跳跃表 o(logn) 、哈希表 o(1)等；\n\n\n\n#### 数据结构\n\n- **String** : 缓存、计数器、限速器、分布式锁、集群共享信息通用配置\n\n- **List** : 消息队列、底层双向链表\n\n- **Set** : 好友关系\n\n- **zset(SortSet)** :排行榜\n\n- **Hash** : \n\n- **Streams(流)** :\n\n![img](https://static001.geekbang.org/resource/image/fb/f0/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg)\n\n\n\n#### 业务场景\n\n- **缓存** string\n\n- **计数器** string\n\n- **排行榜**  Zset\n\n- **异步消息队列** List\n\n- **分布式锁** string  EX seconds | PX milliseconds\n\n- **共享信息、高频访问信息** 如session\n\n- **集合关系** 好友关系  Set\n\n  \n\n#### 分布式锁\n\n```shell\nSET key value [EX seconds | PX milliseconds]  [NX]\n```\n\n分布式锁是由共享存储系统(redis就是其中一种)维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作\n\n- 加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；\n- 锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；\n- 锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。\n\n\n\n#### 持久化策略\n\n- **RDB**: 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。\n\n  相对于大数据集，RDB的启动效率会更高。\n\n- **AOF**: 原理是将Reids的操作日志以追加的方式写入文件。\n\n  通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性\n\n\n\n#### **架构模式**\n\n- **主从**\n\n  1对多，非高可用性\n\n- **哨兵**\n\n  监控从切换成主数据库，浪费资源\n\n- **集群**\n\n  分布式存储，至少需要三主三从\n\n\n\n#### 数据淘汰机制\n\n- volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰\n- volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰\n- volatile-random 从已设置过期时间的数据集中任意选择数据淘汰\n- allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰\n- allkeys-random 从所有数据集中任意选择数据进行淘汰\n- noeviction 禁止驱逐数据\n\n\n\n#### 缓存\n\n- **穿透**:空值设置一个较短的缓存\n- **击穿**(业务狭隘):热门缓存失效\n- **雪崩**:短时间内缓存大量失效  时间后加随机值\n\n\n\n### 缓存\n\n#### 缓存穿透\n\n**概念：**当用户使用一个不存在的key进行查询时，缓存（redis）无法命中，需要访问数据库查询该数据，若数据库中没有数据，则不写入缓存（redis）中，这将导致不存在的数据每次请求都要去数据库查询，造成缓存穿透。\n\n**解决办法：**\n\n1. 使用布隆过滤器，通过bloomfilter.mightContain(key)来判断当前key是否命中。布隆过滤器原理：https://zhuanlan.zhihu.com/p/43263751\n2. 当数据库查询结果为空时，在redis中将key对应的value设置空值，并设置一个较短的过期时间。\n\n\n\n\n\n#### 缓存雪崩\n\n缓存在同一时间内大量·键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。\n\n解决方案：\n\n1、也是像解决缓存穿透一样加锁排队，实现同上;\n\n2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;","slug":"backend/Redis","published":1,"updated":"2021-04-01T08:48:30.673Z","_id":"ckmngmeuz00004qs6gyadfsv7","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h4 id=\"概述特性\"><a href=\"#概述特性\" class=\"headerlink\" title=\"概述特性\"></a>概述特性</h4><ul>\n<li><blockquote>\n<p><strong>Redis为什么这么快？</strong></p>\n</blockquote>\n<ol>\n<li>Redis是单线程的，避免了多线程的上下文切换和并发控制开销；</li>\n<li>Redis大部分操作时基于内存，读写数据不需要磁盘I/O，所以速度非常快；</li>\n<li>Redis采用了I/O多路复用机制，提高了网络I/O并发性；</li>\n<li>Redis提供高效的数据结构，如跳跃表 o(logn) 、哈希表 o(1)等；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><ul>\n<li><p><strong>String</strong> : 缓存、计数器、限速器、分布式锁、集群共享信息通用配置</p>\n</li>\n<li><p><strong>List</strong> : 消息队列、底层双向链表</p>\n</li>\n<li><p><strong>Set</strong> : 好友关系</p>\n</li>\n<li><p><strong>zset(SortSet)</strong> :排行榜</p>\n</li>\n<li><p><strong>Hash</strong> : </p>\n</li>\n<li><p><strong>Streams(流)</strong> :</p>\n</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/fb/f0/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg\" alt=\"img\"></p>\n<h4 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h4><ul>\n<li><p><strong>缓存</strong> string</p>\n</li>\n<li><p><strong>计数器</strong> string</p>\n</li>\n<li><p><strong>排行榜</strong>  Zset</p>\n</li>\n<li><p><strong>异步消息队列</strong> List</p>\n</li>\n<li><p><strong>分布式锁</strong> string  EX seconds | PX milliseconds</p>\n</li>\n<li><p><strong>共享信息、高频访问信息</strong> 如session</p>\n</li>\n<li><p><strong>集合关系</strong> 好友关系  Set</p>\n</li>\n</ul>\n<h4 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">SET key value [EX seconds | PX milliseconds]  [NX]<br></code></pre></td></tr></table></figure>\n\n<p>分布式锁是由共享存储系统(redis就是其中一种)维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作</p>\n<ul>\n<li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li>\n<li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；</li>\n<li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。</li>\n</ul>\n<h4 id=\"持久化策略\"><a href=\"#持久化策略\" class=\"headerlink\" title=\"持久化策略\"></a>持久化策略</h4><ul>\n<li><p><strong>RDB</strong>: 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。</p>\n<p>相对于大数据集，RDB的启动效率会更高。</p>\n</li>\n<li><p><strong>AOF</strong>: 原理是将Reids的操作日志以追加的方式写入文件。</p>\n<p>通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性</p>\n</li>\n</ul>\n<h4 id=\"架构模式\"><a href=\"#架构模式\" class=\"headerlink\" title=\"架构模式\"></a><strong>架构模式</strong></h4><ul>\n<li><p><strong>主从</strong></p>\n<p>1对多，非高可用性</p>\n</li>\n<li><p><strong>哨兵</strong></p>\n<p>监控从切换成主数据库，浪费资源</p>\n</li>\n<li><p><strong>集群</strong></p>\n<p>分布式存储，至少需要三主三从</p>\n</li>\n</ul>\n<h4 id=\"数据淘汰机制\"><a href=\"#数据淘汰机制\" class=\"headerlink\" title=\"数据淘汰机制\"></a>数据淘汰机制</h4><ul>\n<li>volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>\n<li>volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>\n<li>volatile-random 从已设置过期时间的数据集中任意选择数据淘汰</li>\n<li>allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰</li>\n<li>allkeys-random 从所有数据集中任意选择数据进行淘汰</li>\n<li>noeviction 禁止驱逐数据</li>\n</ul>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><ul>\n<li><strong>穿透</strong>:空值设置一个较短的缓存</li>\n<li><strong>击穿</strong>(业务狭隘):热门缓存失效</li>\n<li><strong>雪崩</strong>:短时间内缓存大量失效  时间后加随机值</li>\n</ul>\n<h3 id=\"缓存-1\"><a href=\"#缓存-1\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h4 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h4><p><strong>概念：</strong>当用户使用一个不存在的key进行查询时，缓存（redis）无法命中，需要访问数据库查询该数据，若数据库中没有数据，则不写入缓存（redis）中，这将导致不存在的数据每次请求都要去数据库查询，造成缓存穿透。</p>\n<p><strong>解决办法：</strong></p>\n<ol>\n<li>使用布隆过滤器，通过bloomfilter.mightContain(key)来判断当前key是否命中。布隆过滤器原理：<a href=\"https://zhuanlan.zhihu.com/p/43263751\">https://zhuanlan.zhihu.com/p/43263751</a></li>\n<li>当数据库查询结果为空时，在redis中将key对应的value设置空值，并设置一个较短的过期时间。</li>\n</ol>\n<h4 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h4><p>缓存在同一时间内大量·键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。</p>\n<p>解决方案：</p>\n<p>1、也是像解决缓存穿透一样加锁排队，实现同上;</p>\n<p>2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h1><h4 id=\"概述特性\"><a href=\"#概述特性\" class=\"headerlink\" title=\"概述特性\"></a>概述特性</h4><ul>\n<li><blockquote>\n<p><strong>Redis为什么这么快？</strong></p>\n</blockquote>\n<ol>\n<li>Redis是单线程的，避免了多线程的上下文切换和并发控制开销；</li>\n<li>Redis大部分操作时基于内存，读写数据不需要磁盘I/O，所以速度非常快；</li>\n<li>Redis采用了I/O多路复用机制，提高了网络I/O并发性；</li>\n<li>Redis提供高效的数据结构，如跳跃表 o(logn) 、哈希表 o(1)等；</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><ul>\n<li><p><strong>String</strong> : 缓存、计数器、限速器、分布式锁、集群共享信息通用配置</p>\n</li>\n<li><p><strong>List</strong> : 消息队列、底层双向链表</p>\n</li>\n<li><p><strong>Set</strong> : 好友关系</p>\n</li>\n<li><p><strong>zset(SortSet)</strong> :排行榜</p>\n</li>\n<li><p><strong>Hash</strong> : </p>\n</li>\n<li><p><strong>Streams(流)</strong> :</p>\n</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/fb/f0/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg\" alt=\"img\"></p>\n<h4 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h4><ul>\n<li><p><strong>缓存</strong> string</p>\n</li>\n<li><p><strong>计数器</strong> string</p>\n</li>\n<li><p><strong>排行榜</strong>  Zset</p>\n</li>\n<li><p><strong>异步消息队列</strong> List</p>\n</li>\n<li><p><strong>分布式锁</strong> string  EX seconds | PX milliseconds</p>\n</li>\n<li><p><strong>共享信息、高频访问信息</strong> 如session</p>\n</li>\n<li><p><strong>集合关系</strong> 好友关系  Set</p>\n</li>\n</ul>\n<h4 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">SET key value [EX seconds | PX milliseconds]  [NX]<br></code></pre></td></tr></table></figure>\n\n<p>分布式锁是由共享存储系统(redis就是其中一种)维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作</p>\n<ul>\n<li>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</li>\n<li>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；</li>\n<li>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。</li>\n</ul>\n<h4 id=\"持久化策略\"><a href=\"#持久化策略\" class=\"headerlink\" title=\"持久化策略\"></a>持久化策略</h4><ul>\n<li><p><strong>RDB</strong>: 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。</p>\n<p>相对于大数据集，RDB的启动效率会更高。</p>\n</li>\n<li><p><strong>AOF</strong>: 原理是将Reids的操作日志以追加的方式写入文件。</p>\n<p>通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性</p>\n</li>\n</ul>\n<h4 id=\"架构模式\"><a href=\"#架构模式\" class=\"headerlink\" title=\"架构模式\"></a><strong>架构模式</strong></h4><ul>\n<li><p><strong>主从</strong></p>\n<p>1对多，非高可用性</p>\n</li>\n<li><p><strong>哨兵</strong></p>\n<p>监控从切换成主数据库，浪费资源</p>\n</li>\n<li><p><strong>集群</strong></p>\n<p>分布式存储，至少需要三主三从</p>\n</li>\n</ul>\n<h4 id=\"数据淘汰机制\"><a href=\"#数据淘汰机制\" class=\"headerlink\" title=\"数据淘汰机制\"></a>数据淘汰机制</h4><ul>\n<li>volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>\n<li>volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>\n<li>volatile-random 从已设置过期时间的数据集中任意选择数据淘汰</li>\n<li>allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰</li>\n<li>allkeys-random 从所有数据集中任意选择数据进行淘汰</li>\n<li>noeviction 禁止驱逐数据</li>\n</ul>\n<h4 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h4><ul>\n<li><strong>穿透</strong>:空值设置一个较短的缓存</li>\n<li><strong>击穿</strong>(业务狭隘):热门缓存失效</li>\n<li><strong>雪崩</strong>:短时间内缓存大量失效  时间后加随机值</li>\n</ul>\n<h3 id=\"缓存-1\"><a href=\"#缓存-1\" class=\"headerlink\" title=\"缓存\"></a>缓存</h3><h4 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h4><p><strong>概念：</strong>当用户使用一个不存在的key进行查询时，缓存（redis）无法命中，需要访问数据库查询该数据，若数据库中没有数据，则不写入缓存（redis）中，这将导致不存在的数据每次请求都要去数据库查询，造成缓存穿透。</p>\n<p><strong>解决办法：</strong></p>\n<ol>\n<li>使用布隆过滤器，通过bloomfilter.mightContain(key)来判断当前key是否命中。布隆过滤器原理：<a href=\"https://zhuanlan.zhihu.com/p/43263751\">https://zhuanlan.zhihu.com/p/43263751</a></li>\n<li>当数据库查询结果为空时，在redis中将key对应的value设置空值，并设置一个较短的过期时间。</li>\n</ol>\n<h4 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h4><p>缓存在同一时间内大量·键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。</p>\n<p>解决方案：</p>\n<p>1、也是像解决缓存穿透一样加锁排队，实现同上;</p>\n<p>2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;</p>\n"},{"title":"MySQL","date":"2021-03-27T15:13:11.000Z","_content":"# MySQL\n\n\n\n## SQL\n\n```mysql\n# 从不订购的客户\nselect a.Name as Customers  from Customers  a\nleft join Orders b on a.Id=b.CustomerId \nWhere b.Id is null \n\nselect a.Name as `Customers`  from Customers  a\nwhere id not in (select distinct CustomerId from Orders)\n\n\n# 总分前三的学生姓名\nSELECT `name` from (\n  SELECT b.`name`,SUM(a.score)\n  from score a \n  join student b on a.student_id=b.id\n  GROUP BY  b.`name`\n  ORDER BY SUM(a.score) desc limit 3\n) as t\n\n\n# 每门课成绩前五名\nSELECT a.class,a.`name`,a.score from grade a \nWHERE (SELECT COUNT(1) from grade b WHERE a.class=b.class and  a.score <b.score)<5\nORDER BY class,score desc\n\n\nSELECT a.class,a.`name`,a.score ,COUNT(b.score) as \"No\"   from grade a \nleft join  grade b on a.class=b.class and a.score< b.score\nGROUP BY a.class,a.`name`,a.score\nHAVING COUNT(b.score) <5\nORDER BY a.class,a.score desc\n\n\n\n# 获取所有部门中当前员工薪水最高的相关信息\nselect r.dept_no,ss.emp_no,r.maxSalary from (\n  select d.dept_no,max(s.salary)as maxSalary from dept_emp d,salaries s\n  where d.emp_no=s.emp_no\n  group by d.dept_no\n)as r,salaries ss,dept_emp dd\nwhere r.maxSalary=ss.salary and r.dept_no=dd.dept_no and dd.emp_no=ss.emp_no\norder by r.dept_no asc\n\n\n\n\n```\n\n\n\n> #### **为什么用id做主键**？\n\n1. 行内约定规范（例如阿里官方的java开发手册 id、create_time、update_time 是表的必备字段，其中id为主键）\n2. 可以唯一标识一行，\n3. 数据自增 id 是顺序的，可以保证索引树上的数据比较紧凑，有更高的空间利用率以及减少数据页的分裂合并等操作，提高效率。\n4. 空间占用相对较少 整型做主键，则只要4个字节 利于回表：先在二级索引查询到对应的主键值，然后根据主键再去聚簇索引里面取查询。其他的唯一索引例如手机号、身份证号作为主键等可能比较长 32\n\n\n\n\n\n### 事务\n\nACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）\n\n脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）\n\n### 隔离级别\n\n数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。\n\n- 原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n- 一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\n\n- 隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。\n\n- 持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\n  \n\n- 【**脏读**】读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。\n\n- 【**不可重复读**】读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。\n\n- 【幻读】可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。\n\n- 可串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。\n\n  \n\n不可重复读指的是数据修改、幻读指的是数据增加不涉及修改\n\n\n\n### MVCC\n\n就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。\n\nMVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。","source":"_posts/backend/MySQL.md","raw":"---\ntitle: MySQL\ndate: 2021-03-27 23:13:11\ntags: \n - Database\ncategories: \n - Database\n---\n# MySQL\n\n\n\n## SQL\n\n```mysql\n# 从不订购的客户\nselect a.Name as Customers  from Customers  a\nleft join Orders b on a.Id=b.CustomerId \nWhere b.Id is null \n\nselect a.Name as `Customers`  from Customers  a\nwhere id not in (select distinct CustomerId from Orders)\n\n\n# 总分前三的学生姓名\nSELECT `name` from (\n  SELECT b.`name`,SUM(a.score)\n  from score a \n  join student b on a.student_id=b.id\n  GROUP BY  b.`name`\n  ORDER BY SUM(a.score) desc limit 3\n) as t\n\n\n# 每门课成绩前五名\nSELECT a.class,a.`name`,a.score from grade a \nWHERE (SELECT COUNT(1) from grade b WHERE a.class=b.class and  a.score <b.score)<5\nORDER BY class,score desc\n\n\nSELECT a.class,a.`name`,a.score ,COUNT(b.score) as \"No\"   from grade a \nleft join  grade b on a.class=b.class and a.score< b.score\nGROUP BY a.class,a.`name`,a.score\nHAVING COUNT(b.score) <5\nORDER BY a.class,a.score desc\n\n\n\n# 获取所有部门中当前员工薪水最高的相关信息\nselect r.dept_no,ss.emp_no,r.maxSalary from (\n  select d.dept_no,max(s.salary)as maxSalary from dept_emp d,salaries s\n  where d.emp_no=s.emp_no\n  group by d.dept_no\n)as r,salaries ss,dept_emp dd\nwhere r.maxSalary=ss.salary and r.dept_no=dd.dept_no and dd.emp_no=ss.emp_no\norder by r.dept_no asc\n\n\n\n\n```\n\n\n\n> #### **为什么用id做主键**？\n\n1. 行内约定规范（例如阿里官方的java开发手册 id、create_time、update_time 是表的必备字段，其中id为主键）\n2. 可以唯一标识一行，\n3. 数据自增 id 是顺序的，可以保证索引树上的数据比较紧凑，有更高的空间利用率以及减少数据页的分裂合并等操作，提高效率。\n4. 空间占用相对较少 整型做主键，则只要4个字节 利于回表：先在二级索引查询到对应的主键值，然后根据主键再去聚簇索引里面取查询。其他的唯一索引例如手机号、身份证号作为主键等可能比较长 32\n\n\n\n\n\n### 事务\n\nACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）\n\n脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）\n\n### 隔离级别\n\n数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。\n\n- 原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n- 一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\n\n- 隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。\n\n- 持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\n  \n\n- 【**脏读**】读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。\n\n- 【**不可重复读**】读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。\n\n- 【幻读】可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。\n\n- 可串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。\n\n  \n\n不可重复读指的是数据修改、幻读指的是数据增加不涉及修改\n\n\n\n### MVCC\n\n就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。\n\nMVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。","slug":"backend/MySQL","published":1,"updated":"2021-03-27T15:16:19.623Z","_id":"ckmrvhm9p0000g282evrsfpwd","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 从不订购的客户<br>select a.Name as Customers  from Customers  a<br>left join Orders b on a.Id&#x3D;b.CustomerId <br>Where b.Id is null <br><br>select a.Name as &#96;Customers&#96;  from Customers  a<br>where id not in (select distinct CustomerId from Orders)<br><br><br># 总分前三的学生姓名<br>SELECT &#96;name&#96; from (<br>  SELECT b.&#96;name&#96;,SUM(a.score)<br>  from score a <br>  join student b on a.student_id&#x3D;b.id<br>  GROUP BY  b.&#96;name&#96;<br>  ORDER BY SUM(a.score) desc limit 3<br>) as t<br><br><br># 每门课成绩前五名<br>SELECT a.class,a.&#96;name&#96;,a.score from grade a <br>WHERE (SELECT COUNT(1) from grade b WHERE a.class&#x3D;b.class and  a.score &lt;b.score)&lt;5<br>ORDER BY class,score desc<br><br><br>SELECT a.class,a.&#96;name&#96;,a.score ,COUNT(b.score) as &quot;No&quot;   from grade a <br>left join  grade b on a.class&#x3D;b.class and a.score&lt; b.score<br>GROUP BY a.class,a.&#96;name&#96;,a.score<br>HAVING COUNT(b.score) &lt;5<br>ORDER BY a.class,a.score desc<br><br><br><br># 获取所有部门中当前员工薪水最高的相关信息<br>select r.dept_no,ss.emp_no,r.maxSalary from (<br>  select d.dept_no,max(s.salary)as maxSalary from dept_emp d,salaries s<br>  where d.emp_no&#x3D;s.emp_no<br>  group by d.dept_no<br>)as r,salaries ss,dept_emp dd<br>where r.maxSalary&#x3D;ss.salary and r.dept_no&#x3D;dd.dept_no and dd.emp_no&#x3D;ss.emp_no<br>order by r.dept_no asc<br><br><br><br><br></code></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<h4 id=\"为什么用id做主键？\"><a href=\"#为什么用id做主键？\" class=\"headerlink\" title=\"为什么用id做主键？\"></a><strong>为什么用id做主键</strong>？</h4></blockquote>\n<ol>\n<li>行内约定规范（例如阿里官方的java开发手册 id、create_time、update_time 是表的必备字段，其中id为主键）</li>\n<li>可以唯一标识一行，</li>\n<li>数据自增 id 是顺序的，可以保证索引树上的数据比较紧凑，有更高的空间利用率以及减少数据页的分裂合并等操作，提高效率。</li>\n<li>空间占用相对较少 整型做主键，则只要4个字节 利于回表：先在二级索引查询到对应的主键值，然后根据主键再去聚簇索引里面取查询。其他的唯一索引例如手机号、身份证号作为主键等可能比较长 32</li>\n</ol>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p>\n<p>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><p>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p>\n<ul>\n<li><p>原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>\n</li>\n<li><p>一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>\n</li>\n<li><p>隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</p>\n</li>\n<li><p>持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>\n</li>\n<li><p>【<strong>脏读</strong>】读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</p>\n</li>\n<li><p>【<strong>不可重复读</strong>】读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</p>\n</li>\n<li><p>【幻读】可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p>\n</li>\n<li><p>可串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>\n</li>\n</ul>\n<p>不可重复读指的是数据修改、幻读指的是数据增加不涉及修改</p>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><p>就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p>\n<p>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"SQL\"><a href=\"#SQL\" class=\"headerlink\" title=\"SQL\"></a>SQL</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 从不订购的客户<br>select a.Name as Customers  from Customers  a<br>left join Orders b on a.Id&#x3D;b.CustomerId <br>Where b.Id is null <br><br>select a.Name as &#96;Customers&#96;  from Customers  a<br>where id not in (select distinct CustomerId from Orders)<br><br><br># 总分前三的学生姓名<br>SELECT &#96;name&#96; from (<br>  SELECT b.&#96;name&#96;,SUM(a.score)<br>  from score a <br>  join student b on a.student_id&#x3D;b.id<br>  GROUP BY  b.&#96;name&#96;<br>  ORDER BY SUM(a.score) desc limit 3<br>) as t<br><br><br># 每门课成绩前五名<br>SELECT a.class,a.&#96;name&#96;,a.score from grade a <br>WHERE (SELECT COUNT(1) from grade b WHERE a.class&#x3D;b.class and  a.score &lt;b.score)&lt;5<br>ORDER BY class,score desc<br><br><br>SELECT a.class,a.&#96;name&#96;,a.score ,COUNT(b.score) as &quot;No&quot;   from grade a <br>left join  grade b on a.class&#x3D;b.class and a.score&lt; b.score<br>GROUP BY a.class,a.&#96;name&#96;,a.score<br>HAVING COUNT(b.score) &lt;5<br>ORDER BY a.class,a.score desc<br><br><br><br># 获取所有部门中当前员工薪水最高的相关信息<br>select r.dept_no,ss.emp_no,r.maxSalary from (<br>  select d.dept_no,max(s.salary)as maxSalary from dept_emp d,salaries s<br>  where d.emp_no&#x3D;s.emp_no<br>  group by d.dept_no<br>)as r,salaries ss,dept_emp dd<br>where r.maxSalary&#x3D;ss.salary and r.dept_no&#x3D;dd.dept_no and dd.emp_no&#x3D;ss.emp_no<br>order by r.dept_no asc<br><br><br><br><br></code></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<h4 id=\"为什么用id做主键？\"><a href=\"#为什么用id做主键？\" class=\"headerlink\" title=\"为什么用id做主键？\"></a><strong>为什么用id做主键</strong>？</h4></blockquote>\n<ol>\n<li>行内约定规范（例如阿里官方的java开发手册 id、create_time、update_time 是表的必备字段，其中id为主键）</li>\n<li>可以唯一标识一行，</li>\n<li>数据自增 id 是顺序的，可以保证索引树上的数据比较紧凑，有更高的空间利用率以及减少数据页的分裂合并等操作，提高效率。</li>\n<li>空间占用相对较少 整型做主键，则只要4个字节 利于回表：先在二级索引查询到对应的主键值，然后根据主键再去聚簇索引里面取查询。其他的唯一索引例如手机号、身份证号作为主键等可能比较长 32</li>\n</ol>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p>\n<p>脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）</p>\n<h3 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h3><p>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p>\n<ul>\n<li><p>原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>\n</li>\n<li><p>一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>\n</li>\n<li><p>隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</p>\n</li>\n<li><p>持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>\n</li>\n<li><p>【<strong>脏读</strong>】读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</p>\n</li>\n<li><p>【<strong>不可重复读</strong>】读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</p>\n</li>\n<li><p>【幻读】可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</p>\n</li>\n<li><p>可串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>\n</li>\n</ul>\n<p>不可重复读指的是数据修改、幻读指的是数据增加不涉及修改</p>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><p>就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p>\n<p>MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。</p>\n"},{"title":"操作系统","date":"2021-03-27T15:13:11.000Z","_content":"\n# 操作系统\n\n\n\n### 操作系统概述 \n\n​\t硬件进行抽象和管理，对应用进行服务和管理\n\n\n\n### 进程线程\n\n- **进程**：资源分配的基本单位，执行程序的实例。\n\n- **线程：**cpu调度的基本单元，同进程下的线程共享资源。\n\n- **协程：**协程是一种用户态的轻量级线程，协程程序主动控制切换，没有切换的开销，所以执行效率极高，。\n\n  \n\n\n\n- **并发:**\n- **并行:**\n\n\n\n- 微观上只有一个核心只能同时执行一个进程，\n- 线程与同属一个进程的其他的**线程共享**进程所拥有的全部资源\n\n#### \t状态\n\n​\t\t新生、预备、阻塞、运行、终止\n\n\n\n### 进程通信\n\n1. 管道( pipe )：\n   管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n2. 有名管道 (namedpipe) ：\n   有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。\n3. 信号量(semophore ) ：\n   信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n4. 消息队列( messagequeue ) ：\n   消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n5. 信号 (sinal ) ：\n   信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\n6. 共享内存(shared memory ) ：\n   共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n7. 套接字(socket ) ：\n   套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。\n\n​\t\n\n双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输\n\n### 线程通信\n\n1. 锁机制：包括互斥锁、条件变量、读写锁\n   互斥锁提供了以排他方式防止数据结构被并发修改的方法。\n   读写锁允许多个线程同时读共享数据，而对写操作是互斥的。\n   条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。\n2. 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量\n3. 信号机制(Signal)：类似进程间的信号处理\n   线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。\n\n\n\n#### 死锁\n\n​\t多个线程竞争有限数量的资源，自己持有某种资源又等待其他资源释放，一直在保持这种状态，称为死锁。\n\n​\t\n\n\n\n​\t\n\n","source":"_posts/backend/操作系统.md","raw":"---\ntitle: 操作系统\ndate: 2021-03-27 23:13:11\ntags: \n - CS\ncategories: \n -  ComputerScience\n---\n\n# 操作系统\n\n\n\n### 操作系统概述 \n\n​\t硬件进行抽象和管理，对应用进行服务和管理\n\n\n\n### 进程线程\n\n- **进程**：资源分配的基本单位，执行程序的实例。\n\n- **线程：**cpu调度的基本单元，同进程下的线程共享资源。\n\n- **协程：**协程是一种用户态的轻量级线程，协程程序主动控制切换，没有切换的开销，所以执行效率极高，。\n\n  \n\n\n\n- **并发:**\n- **并行:**\n\n\n\n- 微观上只有一个核心只能同时执行一个进程，\n- 线程与同属一个进程的其他的**线程共享**进程所拥有的全部资源\n\n#### \t状态\n\n​\t\t新生、预备、阻塞、运行、终止\n\n\n\n### 进程通信\n\n1. 管道( pipe )：\n   管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n2. 有名管道 (namedpipe) ：\n   有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。\n3. 信号量(semophore ) ：\n   信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。\n4. 消息队列( messagequeue ) ：\n   消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n5. 信号 (sinal ) ：\n   信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\n6. 共享内存(shared memory ) ：\n   共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。\n7. 套接字(socket ) ：\n   套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。\n\n​\t\n\n双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输\n\n### 线程通信\n\n1. 锁机制：包括互斥锁、条件变量、读写锁\n   互斥锁提供了以排他方式防止数据结构被并发修改的方法。\n   读写锁允许多个线程同时读共享数据，而对写操作是互斥的。\n   条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。\n2. 信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量\n3. 信号机制(Signal)：类似进程间的信号处理\n   线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。\n\n\n\n#### 死锁\n\n​\t多个线程竞争有限数量的资源，自己持有某种资源又等待其他资源释放，一直在保持这种状态，称为死锁。\n\n​\t\n\n\n\n​\t\n\n","slug":"backend/操作系统","published":1,"updated":"2021-03-27T15:28:03.024Z","_id":"ckmrvwj1w0000pw821jru29rx","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><h3 id=\"操作系统概述\"><a href=\"#操作系统概述\" class=\"headerlink\" title=\"操作系统概述\"></a>操作系统概述</h3><p>​    硬件进行抽象和管理，对应用进行服务和管理</p>\n<h3 id=\"进程线程\"><a href=\"#进程线程\" class=\"headerlink\" title=\"进程线程\"></a>进程线程</h3><ul>\n<li><p><strong>进程</strong>：资源分配的基本单位，执行程序的实例。</p>\n</li>\n<li><p><strong>线程：</strong>cpu调度的基本单元，同进程下的线程共享资源。</p>\n</li>\n<li><p><strong>协程：</strong>协程是一种用户态的轻量级线程，协程程序主动控制切换，没有切换的开销，所以执行效率极高，。</p>\n</li>\n</ul>\n<ul>\n<li><strong>并发:</strong></li>\n<li><strong>并行:</strong></li>\n</ul>\n<ul>\n<li>微观上只有一个核心只能同时执行一个进程，</li>\n<li>线程与同属一个进程的其他的<strong>线程共享</strong>进程所拥有的全部资源</li>\n</ul>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><p>​        新生、预备、阻塞、运行、终止</p>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><ol>\n<li>管道( pipe )：<br>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>\n<li>有名管道 (namedpipe) ：<br>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>\n<li>信号量(semophore ) ：<br>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>\n<li>消息队列( messagequeue ) ：<br>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>\n<li>信号 (sinal ) ：<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>\n<li>共享内存(shared memory ) ：<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>\n<li>套接字(socket ) ：<br>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</li>\n</ol>\n<p>​    </p>\n<p>双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输</p>\n<h3 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h3><ol>\n<li>锁机制：包括互斥锁、条件变量、读写锁<br>互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>\n<li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li>\n<li>信号机制(Signal)：类似进程间的信号处理<br>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</li>\n</ol>\n<h4 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h4><p>​    多个线程竞争有限数量的资源，自己持有某种资源又等待其他资源释放，一直在保持这种状态，称为死锁。</p>\n<p>​    </p>\n<p>​    </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><h3 id=\"操作系统概述\"><a href=\"#操作系统概述\" class=\"headerlink\" title=\"操作系统概述\"></a>操作系统概述</h3><p>​    硬件进行抽象和管理，对应用进行服务和管理</p>\n<h3 id=\"进程线程\"><a href=\"#进程线程\" class=\"headerlink\" title=\"进程线程\"></a>进程线程</h3><ul>\n<li><p><strong>进程</strong>：资源分配的基本单位，执行程序的实例。</p>\n</li>\n<li><p><strong>线程：</strong>cpu调度的基本单元，同进程下的线程共享资源。</p>\n</li>\n<li><p><strong>协程：</strong>协程是一种用户态的轻量级线程，协程程序主动控制切换，没有切换的开销，所以执行效率极高，。</p>\n</li>\n</ul>\n<ul>\n<li><strong>并发:</strong></li>\n<li><strong>并行:</strong></li>\n</ul>\n<ul>\n<li>微观上只有一个核心只能同时执行一个进程，</li>\n<li>线程与同属一个进程的其他的<strong>线程共享</strong>进程所拥有的全部资源</li>\n</ul>\n<h4 id=\"状态\"><a href=\"#状态\" class=\"headerlink\" title=\"状态\"></a>状态</h4><p>​        新生、预备、阻塞、运行、终止</p>\n<h3 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h3><ol>\n<li>管道( pipe )：<br>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>\n<li>有名管道 (namedpipe) ：<br>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>\n<li>信号量(semophore ) ：<br>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>\n<li>消息队列( messagequeue ) ：<br>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>\n<li>信号 (sinal ) ：<br>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>\n<li>共享内存(shared memory ) ：<br>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>\n<li>套接字(socket ) ：<br>套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</li>\n</ol>\n<p>​    </p>\n<p>双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输</p>\n<h3 id=\"线程通信\"><a href=\"#线程通信\" class=\"headerlink\" title=\"线程通信\"></a>线程通信</h3><ol>\n<li>锁机制：包括互斥锁、条件变量、读写锁<br>互斥锁提供了以排他方式防止数据结构被并发修改的方法。<br>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。<br>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>\n<li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li>\n<li>信号机制(Signal)：类似进程间的信号处理<br>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</li>\n</ol>\n<h4 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h4><p>​    多个线程竞争有限数量的资源，自己持有某种资源又等待其他资源释放，一直在保持这种状态，称为死锁。</p>\n<p>​    </p>\n<p>​    </p>\n"},{"title":"Python","date":"2021-03-27T15:26:11.000Z","_content":"# Python\n\n\n\n\n\n#### 进程/线程/协程\n\n进程下的多个线程可以共享该进程的所有资源，进程之间相互独立\n\n- **多进程**:cpu密集走进程,进程资源开销大，但相对稳定\n- **多线程:**io密集走线程,python 有gil多线程只能发挥单核的性能 \n\n在CPU密集的程序中，线程有点鸡肋，无法发挥多处理器的效率，这一点可以用进程来做。\n\n在IO 密集的程序中，大量时间都花在等待IO上，对CPU不敏感，线程可以很好的胜任。\n\n\n\n\n\n### 内存管理机制 \n\n#### 一、对象的引用计数机制\n\nPython内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。\n\n引用计数增加的情况：\n\n1，一个对象分配一个新名称\n\n2，将其放入一个容器中（如列表、元组或字典）\n\n引用计数减少的情况：\n\n1，使用del语句对对象别名显示的销毁\n\n2，引用超出作用域或被重新赋值\n\n#### 二、垃圾回收\n\n1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。\n\n2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。\n\n#### 三、内存池机制\n\nPython提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。\n\n1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。\n\n\n\n\n\n#### with底层实现\t\n\n```python\n__inter和 __end 方法\n```\n\n\n\n#### 元类\n\n​\t相当于类的父类 用于创建类。python所以的东西都是对象，都是从一个类里面创建出来的，type就是python的内建元类。\n\n\n\n### asyncio\n\n​\t异步非阻塞，内部可以await 停止做其他的操作比如网络\n\n​\t\n\n\n\nType Hint\n\n​\t有提示\n\n\n\n#### 私有变量\n\n- 约定俗成、不是强制\n\n\n\n#### 性能调优\n\n​\t分cpu密集型还是网络密集型的程序\n\n- 分本身考虑sql\n- 接口 异步 协成\n- cpu换成c或者考虑多进程、pypy\n\n\n\n#### 魔术方法（Magic Method）\n\n\n\n#### `__init__ / __new__`\n\n1. init是初始化方法 实例方法，new是构造方法 静态方法\n2. new在init之前执行, 用于创建对象并返回对象（可返回实例如不可变对象）\n3. init返回None、new返回对象或者实例\n4. 绝大多数情况下，我们都不需要自己重写__new__方法，但在当继承一个不可变的类型（例如str类,int类等）时，则需要用到new。\n\n#### `__getter__ / __setter__`\n\n\n\n#### `__doc__`\n\n文档字符串\n\n\n\n### 装饰器\n\n抽离出大量函数中与函数功能本身无关的雷同代码并继续重用\n\n- 日志\n- 资源开销型 with外写\n\n### 生成器\n\n[Generator](https://docs.python.org/zh-cn/3/glossary.html#term-generator) 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用 [`yield`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield) 语句。\n\n```python\ng = (x*x for x in range(10))\n```\n\n### 迭代器 iter()\n\n```python\n>>> a = iter([1,2,3])\n>>> a\n<list_iterator object at 0x10abbac50>\n>>> a.__next__()\n1\n>>> a.__next__()\n2\n```\n\n\n\n### 多重继承\n\n搜索从父类所继承属性的操作是深度优先、从左至右、递归查找。 派生类方法覆盖重载基类\n\n\n\n#### metaclass\n\n元类 orm用的\n\n\n\n#### Classmethod / staticmethod\n\n​\t\t**相同**\n\n- 都不需要实例化，即可调用\n\n- 类方法需要cls参数传入，静态函数则不用\n\n  **区别**\n\n- 类函数可以当做作为类似`__new__`一样的构造函数，用来返回类对象\n\n  \n\n#### args/kwargs\n\nargs 不定数量的输入参数\n\nkwargs 不定数量的键值对输入参数\n\n`*args`必须在`**kwargs`前面\n\n\n\n\n\n# WSGI\n\nweb server如何与web application通信的规范\n\n其实就是一个规范，他规范了Python程序和服务器之间的通信。对于Apache/Nginx等等服务器来说，只要支持WSGI规范，就可以保证所有(兼容WSGI的)Python程序能运行；对于Python程序或者框架来说，只要兼容WSGI，就可以保证能在所有(支持WSGI的)服务器上运行。这是WSGI的重要性，而那篇文章则是更深入的探讨了WSGI的设计，以及有没有什么可以提升的地方。\n\n\n\n\n一个HTTP请求的过程可以分为两个阶段，第一阶段是从客户端到WSGI Server，第二阶段是从WSGI Server 到WSGI Application\n\n\n\n**1、两级结构** 在这种结构里，uWSGI作为服务器，它用到了HTTP协议以及wsgi协议，flask应用作为application，实现了wsgi协议。当有客户端发来请求，uWSGI接受请求，调用flask app得到相应，之后相应给客户端。 这里说一点，通常来说，Flask等web框架会自己附带一个wsgi服务器(这就是flask应用可以直接启动的原因)，但是这只是在开发阶段用到的，在生产环境是不够用的，所以用到了uwsgi这个性能高的wsgi服务器。\n\n**2、三级结构** 这种结构里，uWSGI作为中间件，它用到了uwsgi协议(与nginx通信)，wsgi协议(调用Flask app)。当有客户端发来请求，nginx先做处理(静态资源是nginx的强项)，无法处理的请求(uWSGI)，最后的相应也是nginx回复给客户端的。 多了一层反向代理有什么好处？\n\n提高web server性能(uWSGI处理静态资源不如nginx；nginx会在收到一个完整的http请求后再转发给wWSGI)\n\nnginx可以做负载均衡(前提是有多个服务器)，保护了实际的web服务器(客户端是和nginx交互而不是uWSGI)","source":"_posts/backend/Python.md","raw":"---\ntitle: Python\ndate: 2021-03-27 23:26:11\ntags: \n - Python\ncategories: \n - Python\n---\n# Python\n\n\n\n\n\n#### 进程/线程/协程\n\n进程下的多个线程可以共享该进程的所有资源，进程之间相互独立\n\n- **多进程**:cpu密集走进程,进程资源开销大，但相对稳定\n- **多线程:**io密集走线程,python 有gil多线程只能发挥单核的性能 \n\n在CPU密集的程序中，线程有点鸡肋，无法发挥多处理器的效率，这一点可以用进程来做。\n\n在IO 密集的程序中，大量时间都花在等待IO上，对CPU不敏感，线程可以很好的胜任。\n\n\n\n\n\n### 内存管理机制 \n\n#### 一、对象的引用计数机制\n\nPython内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。\n\n引用计数增加的情况：\n\n1，一个对象分配一个新名称\n\n2，将其放入一个容器中（如列表、元组或字典）\n\n引用计数减少的情况：\n\n1，使用del语句对对象别名显示的销毁\n\n2，引用超出作用域或被重新赋值\n\n#### 二、垃圾回收\n\n1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。\n\n2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。\n\n#### 三、内存池机制\n\nPython提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。\n\n1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。\n\n\n\n\n\n#### with底层实现\t\n\n```python\n__inter和 __end 方法\n```\n\n\n\n#### 元类\n\n​\t相当于类的父类 用于创建类。python所以的东西都是对象，都是从一个类里面创建出来的，type就是python的内建元类。\n\n\n\n### asyncio\n\n​\t异步非阻塞，内部可以await 停止做其他的操作比如网络\n\n​\t\n\n\n\nType Hint\n\n​\t有提示\n\n\n\n#### 私有变量\n\n- 约定俗成、不是强制\n\n\n\n#### 性能调优\n\n​\t分cpu密集型还是网络密集型的程序\n\n- 分本身考虑sql\n- 接口 异步 协成\n- cpu换成c或者考虑多进程、pypy\n\n\n\n#### 魔术方法（Magic Method）\n\n\n\n#### `__init__ / __new__`\n\n1. init是初始化方法 实例方法，new是构造方法 静态方法\n2. new在init之前执行, 用于创建对象并返回对象（可返回实例如不可变对象）\n3. init返回None、new返回对象或者实例\n4. 绝大多数情况下，我们都不需要自己重写__new__方法，但在当继承一个不可变的类型（例如str类,int类等）时，则需要用到new。\n\n#### `__getter__ / __setter__`\n\n\n\n#### `__doc__`\n\n文档字符串\n\n\n\n### 装饰器\n\n抽离出大量函数中与函数功能本身无关的雷同代码并继续重用\n\n- 日志\n- 资源开销型 with外写\n\n### 生成器\n\n[Generator](https://docs.python.org/zh-cn/3/glossary.html#term-generator) 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用 [`yield`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield) 语句。\n\n```python\ng = (x*x for x in range(10))\n```\n\n### 迭代器 iter()\n\n```python\n>>> a = iter([1,2,3])\n>>> a\n<list_iterator object at 0x10abbac50>\n>>> a.__next__()\n1\n>>> a.__next__()\n2\n```\n\n\n\n### 多重继承\n\n搜索从父类所继承属性的操作是深度优先、从左至右、递归查找。 派生类方法覆盖重载基类\n\n\n\n#### metaclass\n\n元类 orm用的\n\n\n\n#### Classmethod / staticmethod\n\n​\t\t**相同**\n\n- 都不需要实例化，即可调用\n\n- 类方法需要cls参数传入，静态函数则不用\n\n  **区别**\n\n- 类函数可以当做作为类似`__new__`一样的构造函数，用来返回类对象\n\n  \n\n#### args/kwargs\n\nargs 不定数量的输入参数\n\nkwargs 不定数量的键值对输入参数\n\n`*args`必须在`**kwargs`前面\n\n\n\n\n\n# WSGI\n\nweb server如何与web application通信的规范\n\n其实就是一个规范，他规范了Python程序和服务器之间的通信。对于Apache/Nginx等等服务器来说，只要支持WSGI规范，就可以保证所有(兼容WSGI的)Python程序能运行；对于Python程序或者框架来说，只要兼容WSGI，就可以保证能在所有(支持WSGI的)服务器上运行。这是WSGI的重要性，而那篇文章则是更深入的探讨了WSGI的设计，以及有没有什么可以提升的地方。\n\n\n\n\n一个HTTP请求的过程可以分为两个阶段，第一阶段是从客户端到WSGI Server，第二阶段是从WSGI Server 到WSGI Application\n\n\n\n**1、两级结构** 在这种结构里，uWSGI作为服务器，它用到了HTTP协议以及wsgi协议，flask应用作为application，实现了wsgi协议。当有客户端发来请求，uWSGI接受请求，调用flask app得到相应，之后相应给客户端。 这里说一点，通常来说，Flask等web框架会自己附带一个wsgi服务器(这就是flask应用可以直接启动的原因)，但是这只是在开发阶段用到的，在生产环境是不够用的，所以用到了uwsgi这个性能高的wsgi服务器。\n\n**2、三级结构** 这种结构里，uWSGI作为中间件，它用到了uwsgi协议(与nginx通信)，wsgi协议(调用Flask app)。当有客户端发来请求，nginx先做处理(静态资源是nginx的强项)，无法处理的请求(uWSGI)，最后的相应也是nginx回复给客户端的。 多了一层反向代理有什么好处？\n\n提高web server性能(uWSGI处理静态资源不如nginx；nginx会在收到一个完整的http请求后再转发给wWSGI)\n\nnginx可以做负载均衡(前提是有多个服务器)，保护了实际的web服务器(客户端是和nginx交互而不是uWSGI)","slug":"backend/Python","published":1,"updated":"2021-03-27T15:26:17.598Z","_id":"ckmrvyjrm0004pw82dlwagn8g","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h4 id=\"进程-线程-协程\"><a href=\"#进程-线程-协程\" class=\"headerlink\" title=\"进程/线程/协程\"></a>进程/线程/协程</h4><p>进程下的多个线程可以共享该进程的所有资源，进程之间相互独立</p>\n<ul>\n<li><strong>多进程</strong>:cpu密集走进程,进程资源开销大，但相对稳定</li>\n<li>**多线程:**io密集走线程,python 有gil多线程只能发挥单核的性能 </li>\n</ul>\n<p>在CPU密集的程序中，线程有点鸡肋，无法发挥多处理器的效率，这一点可以用进程来做。</p>\n<p>在IO 密集的程序中，大量时间都花在等待IO上，对CPU不敏感，线程可以很好的胜任。</p>\n<h3 id=\"内存管理机制\"><a href=\"#内存管理机制\" class=\"headerlink\" title=\"内存管理机制\"></a>内存管理机制</h3><h4 id=\"一、对象的引用计数机制\"><a href=\"#一、对象的引用计数机制\" class=\"headerlink\" title=\"一、对象的引用计数机制\"></a>一、对象的引用计数机制</h4><p>Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。</p>\n<p>引用计数增加的情况：</p>\n<p>1，一个对象分配一个新名称</p>\n<p>2，将其放入一个容器中（如列表、元组或字典）</p>\n<p>引用计数减少的情况：</p>\n<p>1，使用del语句对对象别名显示的销毁</p>\n<p>2，引用超出作用域或被重新赋值</p>\n<h4 id=\"二、垃圾回收\"><a href=\"#二、垃圾回收\" class=\"headerlink\" title=\"二、垃圾回收\"></a>二、垃圾回收</h4><p>1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。</p>\n<p>2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。</p>\n<h4 id=\"三、内存池机制\"><a href=\"#三、内存池机制\" class=\"headerlink\" title=\"三、内存池机制\"></a>三、内存池机制</h4><p>Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。</p>\n<p>1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。</p>\n<h4 id=\"with底层实现\"><a href=\"#with底层实现\" class=\"headerlink\" title=\"with底层实现\"></a>with底层实现</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">__inter和 __end 方法<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"元类\"><a href=\"#元类\" class=\"headerlink\" title=\"元类\"></a>元类</h4><p>​    相当于类的父类 用于创建类。python所以的东西都是对象，都是从一个类里面创建出来的，type就是python的内建元类。</p>\n<h3 id=\"asyncio\"><a href=\"#asyncio\" class=\"headerlink\" title=\"asyncio\"></a>asyncio</h3><p>​    异步非阻塞，内部可以await 停止做其他的操作比如网络</p>\n<p>​    </p>\n<p>Type Hint</p>\n<p>​    有提示</p>\n<h4 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h4><ul>\n<li>约定俗成、不是强制</li>\n</ul>\n<h4 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h4><p>​    分cpu密集型还是网络密集型的程序</p>\n<ul>\n<li>分本身考虑sql</li>\n<li>接口 异步 协成</li>\n<li>cpu换成c或者考虑多进程、pypy</li>\n</ul>\n<h4 id=\"魔术方法（Magic-Method）\"><a href=\"#魔术方法（Magic-Method）\" class=\"headerlink\" title=\"魔术方法（Magic Method）\"></a>魔术方法（Magic Method）</h4><h4 id=\"init-new\"><a href=\"#init-new\" class=\"headerlink\" title=\"__init__ / __new__\"></a><code>__init__ / __new__</code></h4><ol>\n<li>init是初始化方法 实例方法，new是构造方法 静态方法</li>\n<li>new在init之前执行, 用于创建对象并返回对象（可返回实例如不可变对象）</li>\n<li>init返回None、new返回对象或者实例</li>\n<li>绝大多数情况下，我们都不需要自己重写__new__方法，但在当继承一个不可变的类型（例如str类,int类等）时，则需要用到new。</li>\n</ol>\n<h4 id=\"getter-setter\"><a href=\"#getter-setter\" class=\"headerlink\" title=\"__getter__ / __setter__\"></a><code>__getter__ / __setter__</code></h4><h4 id=\"doc\"><a href=\"#doc\" class=\"headerlink\" title=\"__doc__\"></a><code>__doc__</code></h4><p>文档字符串</p>\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><p>抽离出大量函数中与函数功能本身无关的雷同代码并继续重用</p>\n<ul>\n<li>日志</li>\n<li>资源开销型 with外写</li>\n</ul>\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p><a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-generator\">Generator</a> 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield\"><code>yield</code></a> 语句。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">g = (x*x <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">10</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"迭代器-iter\"><a href=\"#迭代器-iter\" class=\"headerlink\" title=\"迭代器 iter()\"></a>迭代器 iter()</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>a = <span class=\"hljs-built_in\">iter</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>])<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>a<br>&lt;list_iterator <span class=\"hljs-built_in\">object</span> at <span class=\"hljs-number\">0x10abbac50</span>&gt;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>a.__next__()<br><span class=\"hljs-number\">1</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>a.__next__()<br><span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p>搜索从父类所继承属性的操作是深度优先、从左至右、递归查找。 派生类方法覆盖重载基类</p>\n<h4 id=\"metaclass\"><a href=\"#metaclass\" class=\"headerlink\" title=\"metaclass\"></a>metaclass</h4><p>元类 orm用的</p>\n<h4 id=\"Classmethod-staticmethod\"><a href=\"#Classmethod-staticmethod\" class=\"headerlink\" title=\"Classmethod / staticmethod\"></a>Classmethod / staticmethod</h4><p>​        <strong>相同</strong></p>\n<ul>\n<li><p>都不需要实例化，即可调用</p>\n</li>\n<li><p>类方法需要cls参数传入，静态函数则不用</p>\n<p><strong>区别</strong></p>\n</li>\n<li><p>类函数可以当做作为类似<code>__new__</code>一样的构造函数，用来返回类对象</p>\n</li>\n</ul>\n<h4 id=\"args-kwargs\"><a href=\"#args-kwargs\" class=\"headerlink\" title=\"args/kwargs\"></a>args/kwargs</h4><p>args 不定数量的输入参数</p>\n<p>kwargs 不定数量的键值对输入参数</p>\n<p><code>*args</code>必须在<code>**kwargs</code>前面</p>\n<h1 id=\"WSGI\"><a href=\"#WSGI\" class=\"headerlink\" title=\"WSGI\"></a>WSGI</h1><p>web server如何与web application通信的规范</p>\n<p>其实就是一个规范，他规范了Python程序和服务器之间的通信。对于Apache/Nginx等等服务器来说，只要支持WSGI规范，就可以保证所有(兼容WSGI的)Python程序能运行；对于Python程序或者框架来说，只要兼容WSGI，就可以保证能在所有(支持WSGI的)服务器上运行。这是WSGI的重要性，而那篇文章则是更深入的探讨了WSGI的设计，以及有没有什么可以提升的地方。</p>\n<p>一个HTTP请求的过程可以分为两个阶段，第一阶段是从客户端到WSGI Server，第二阶段是从WSGI Server 到WSGI Application</p>\n<p><strong>1、两级结构</strong> 在这种结构里，uWSGI作为服务器，它用到了HTTP协议以及wsgi协议，flask应用作为application，实现了wsgi协议。当有客户端发来请求，uWSGI接受请求，调用flask app得到相应，之后相应给客户端。 这里说一点，通常来说，Flask等web框架会自己附带一个wsgi服务器(这就是flask应用可以直接启动的原因)，但是这只是在开发阶段用到的，在生产环境是不够用的，所以用到了uwsgi这个性能高的wsgi服务器。</p>\n<p><strong>2、三级结构</strong> 这种结构里，uWSGI作为中间件，它用到了uwsgi协议(与nginx通信)，wsgi协议(调用Flask app)。当有客户端发来请求，nginx先做处理(静态资源是nginx的强项)，无法处理的请求(uWSGI)，最后的相应也是nginx回复给客户端的。 多了一层反向代理有什么好处？</p>\n<p>提高web server性能(uWSGI处理静态资源不如nginx；nginx会在收到一个完整的http请求后再转发给wWSGI)</p>\n<p>nginx可以做负载均衡(前提是有多个服务器)，保护了实际的web服务器(客户端是和nginx交互而不是uWSGI)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h1><h4 id=\"进程-线程-协程\"><a href=\"#进程-线程-协程\" class=\"headerlink\" title=\"进程/线程/协程\"></a>进程/线程/协程</h4><p>进程下的多个线程可以共享该进程的所有资源，进程之间相互独立</p>\n<ul>\n<li><strong>多进程</strong>:cpu密集走进程,进程资源开销大，但相对稳定</li>\n<li>**多线程:**io密集走线程,python 有gil多线程只能发挥单核的性能 </li>\n</ul>\n<p>在CPU密集的程序中，线程有点鸡肋，无法发挥多处理器的效率，这一点可以用进程来做。</p>\n<p>在IO 密集的程序中，大量时间都花在等待IO上，对CPU不敏感，线程可以很好的胜任。</p>\n<h3 id=\"内存管理机制\"><a href=\"#内存管理机制\" class=\"headerlink\" title=\"内存管理机制\"></a>内存管理机制</h3><h4 id=\"一、对象的引用计数机制\"><a href=\"#一、对象的引用计数机制\" class=\"headerlink\" title=\"一、对象的引用计数机制\"></a>一、对象的引用计数机制</h4><p>Python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。</p>\n<p>引用计数增加的情况：</p>\n<p>1，一个对象分配一个新名称</p>\n<p>2，将其放入一个容器中（如列表、元组或字典）</p>\n<p>引用计数减少的情况：</p>\n<p>1，使用del语句对对象别名显示的销毁</p>\n<p>2，引用超出作用域或被重新赋值</p>\n<h4 id=\"二、垃圾回收\"><a href=\"#二、垃圾回收\" class=\"headerlink\" title=\"二、垃圾回收\"></a>二、垃圾回收</h4><p>1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。</p>\n<p>2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。</p>\n<h4 id=\"三、内存池机制\"><a href=\"#三、内存池机制\" class=\"headerlink\" title=\"三、内存池机制\"></a>三、内存池机制</h4><p>Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。</p>\n<p>1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。</p>\n<h4 id=\"with底层实现\"><a href=\"#with底层实现\" class=\"headerlink\" title=\"with底层实现\"></a>with底层实现</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">__inter和 __end 方法<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"元类\"><a href=\"#元类\" class=\"headerlink\" title=\"元类\"></a>元类</h4><p>​    相当于类的父类 用于创建类。python所以的东西都是对象，都是从一个类里面创建出来的，type就是python的内建元类。</p>\n<h3 id=\"asyncio\"><a href=\"#asyncio\" class=\"headerlink\" title=\"asyncio\"></a>asyncio</h3><p>​    异步非阻塞，内部可以await 停止做其他的操作比如网络</p>\n<p>​    </p>\n<p>Type Hint</p>\n<p>​    有提示</p>\n<h4 id=\"私有变量\"><a href=\"#私有变量\" class=\"headerlink\" title=\"私有变量\"></a>私有变量</h4><ul>\n<li>约定俗成、不是强制</li>\n</ul>\n<h4 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h4><p>​    分cpu密集型还是网络密集型的程序</p>\n<ul>\n<li>分本身考虑sql</li>\n<li>接口 异步 协成</li>\n<li>cpu换成c或者考虑多进程、pypy</li>\n</ul>\n<h4 id=\"魔术方法（Magic-Method）\"><a href=\"#魔术方法（Magic-Method）\" class=\"headerlink\" title=\"魔术方法（Magic Method）\"></a>魔术方法（Magic Method）</h4><h4 id=\"init-new\"><a href=\"#init-new\" class=\"headerlink\" title=\"__init__ / __new__\"></a><code>__init__ / __new__</code></h4><ol>\n<li>init是初始化方法 实例方法，new是构造方法 静态方法</li>\n<li>new在init之前执行, 用于创建对象并返回对象（可返回实例如不可变对象）</li>\n<li>init返回None、new返回对象或者实例</li>\n<li>绝大多数情况下，我们都不需要自己重写__new__方法，但在当继承一个不可变的类型（例如str类,int类等）时，则需要用到new。</li>\n</ol>\n<h4 id=\"getter-setter\"><a href=\"#getter-setter\" class=\"headerlink\" title=\"__getter__ / __setter__\"></a><code>__getter__ / __setter__</code></h4><h4 id=\"doc\"><a href=\"#doc\" class=\"headerlink\" title=\"__doc__\"></a><code>__doc__</code></h4><p>文档字符串</p>\n<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><p>抽离出大量函数中与函数功能本身无关的雷同代码并继续重用</p>\n<ul>\n<li>日志</li>\n<li>资源开销型 with外写</li>\n</ul>\n<h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p><a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-generator\">Generator</a> 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#yield\"><code>yield</code></a> 语句。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\">g = (x*x <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">10</span>))<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"迭代器-iter\"><a href=\"#迭代器-iter\" class=\"headerlink\" title=\"迭代器 iter()\"></a>迭代器 iter()</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-meta\">&gt;&gt;&gt; </span>a = <span class=\"hljs-built_in\">iter</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>])<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>a<br>&lt;list_iterator <span class=\"hljs-built_in\">object</span> at <span class=\"hljs-number\">0x10abbac50</span>&gt;<br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>a.__next__()<br><span class=\"hljs-number\">1</span><br><span class=\"hljs-meta\">&gt;&gt;&gt; </span>a.__next__()<br><span class=\"hljs-number\">2</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h3><p>搜索从父类所继承属性的操作是深度优先、从左至右、递归查找。 派生类方法覆盖重载基类</p>\n<h4 id=\"metaclass\"><a href=\"#metaclass\" class=\"headerlink\" title=\"metaclass\"></a>metaclass</h4><p>元类 orm用的</p>\n<h4 id=\"Classmethod-staticmethod\"><a href=\"#Classmethod-staticmethod\" class=\"headerlink\" title=\"Classmethod / staticmethod\"></a>Classmethod / staticmethod</h4><p>​        <strong>相同</strong></p>\n<ul>\n<li><p>都不需要实例化，即可调用</p>\n</li>\n<li><p>类方法需要cls参数传入，静态函数则不用</p>\n<p><strong>区别</strong></p>\n</li>\n<li><p>类函数可以当做作为类似<code>__new__</code>一样的构造函数，用来返回类对象</p>\n</li>\n</ul>\n<h4 id=\"args-kwargs\"><a href=\"#args-kwargs\" class=\"headerlink\" title=\"args/kwargs\"></a>args/kwargs</h4><p>args 不定数量的输入参数</p>\n<p>kwargs 不定数量的键值对输入参数</p>\n<p><code>*args</code>必须在<code>**kwargs</code>前面</p>\n<h1 id=\"WSGI\"><a href=\"#WSGI\" class=\"headerlink\" title=\"WSGI\"></a>WSGI</h1><p>web server如何与web application通信的规范</p>\n<p>其实就是一个规范，他规范了Python程序和服务器之间的通信。对于Apache/Nginx等等服务器来说，只要支持WSGI规范，就可以保证所有(兼容WSGI的)Python程序能运行；对于Python程序或者框架来说，只要兼容WSGI，就可以保证能在所有(支持WSGI的)服务器上运行。这是WSGI的重要性，而那篇文章则是更深入的探讨了WSGI的设计，以及有没有什么可以提升的地方。</p>\n<p>一个HTTP请求的过程可以分为两个阶段，第一阶段是从客户端到WSGI Server，第二阶段是从WSGI Server 到WSGI Application</p>\n<p><strong>1、两级结构</strong> 在这种结构里，uWSGI作为服务器，它用到了HTTP协议以及wsgi协议，flask应用作为application，实现了wsgi协议。当有客户端发来请求，uWSGI接受请求，调用flask app得到相应，之后相应给客户端。 这里说一点，通常来说，Flask等web框架会自己附带一个wsgi服务器(这就是flask应用可以直接启动的原因)，但是这只是在开发阶段用到的，在生产环境是不够用的，所以用到了uwsgi这个性能高的wsgi服务器。</p>\n<p><strong>2、三级结构</strong> 这种结构里，uWSGI作为中间件，它用到了uwsgi协议(与nginx通信)，wsgi协议(调用Flask app)。当有客户端发来请求，nginx先做处理(静态资源是nginx的强项)，无法处理的请求(uWSGI)，最后的相应也是nginx回复给客户端的。 多了一层反向代理有什么好处？</p>\n<p>提高web server性能(uWSGI处理静态资源不如nginx；nginx会在收到一个完整的http请求后再转发给wWSGI)</p>\n<p>nginx可以做负载均衡(前提是有多个服务器)，保护了实际的web服务器(客户端是和nginx交互而不是uWSGI)</p>\n"},{"title":"计算机网络","date":"2021-03-27T15:13:11.000Z","_content":"# 计算机网络\n### url解析返回\n\n1. ip解析:缓存(浏览器和操作系统)-/etc/hosts-根域名-顶级域名-权威(二级)域名\n\n2. 网络层 ip协议 arp协议 mac地址查询\n\n3. 传输层 TCP 连接：TCP 三次握手\n\n4. 应用层 HTTP 连接: 发送 HTTP 请求\n\n5. cdn直接返回/非cdn服务器监听对应端口 处理请求\n\n6. 七层nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口\n\n7. k8s、docker监听端口处理\n\n8. python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn\n\n9. 框架处理（flask/django/fastapi）解析http报文 \n\n10. 查询redis缓存/mysql\n\n11. 组装数据并返回 HTTP 报文 json/text/file返回\n\n12. 浏览器解析渲染页面/前端直接处理的json/xml数据\n\n13. 断开连接：TCP 四次挥手\n\n    \n\n### 网络协议\n\n1.host里面找ip没有从dns里面找\n\n2.请求ip地址 建立连接、nginx静态模板->WSGI服务器 gunicorn ->flask web application -> 返回\n\n\n\n- **应用层** FTP、DNS、Telnet、SMTP、HTTP\n- 表示层  数据压缩，数据加密以及数据描述\n- 会话层   DNS\n- **传输层** tcp、udp\n- **网络层** ip、ARP\n- **数据链路层** PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） \n- **物理层** IEEE   （中继器，集线器，网关）\n\n\n\n### ARP协议\n\n**即地址解析协议（Address Resolution Protocol）， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址**。\n\n基于功能来考虑，ARP是链路层协议；基于分层/包封装来考虑，ARP是网络层协议。\n\n\n\n### Rpc/http区别\n\n**http**:**有用信息占比少**，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是**效率低**，还是因为第七层的缘故.\n\n基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。\n\n\n\n### DNS\n\n\n\n### Tcp **三次握手**\n\n\n\n其中ACK报文是用来应答的，SYN报文是用来同步的\n\n\n\n**作用**：确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备\n\n第一次、第二次不携带数据，防止恶意攻击\n\n\n\n 第一次握手：[客户端]()发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； \n\n 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； \n\n 第三次握手：[客户端]()收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，[客户端]()和服务器进入ESTABLISHED状态，完成三次握手。 \n\n 握手过程中传送的包里不包含数据，三次握手完毕后，[客户端]()与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 \n\n###  Tcp四次挥手\n\n 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。 \n\n 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 \n\n 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。\n 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。\n 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。\n\n###  交换机\n\n 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。 \n\n 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。 \n\n 交换机被广泛应用于二层网络交换，俗称“二层交换机”。 \n\n 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。 \n\n### 路由器  \n\n **路由器**（**Router**）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 \n\n **路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。** 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 \n\n\n\n### 网关 \n\n **网关**（Gateway），**网关**顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 \n\n 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。 \n\n 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 \n\n **网关**是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过**网关**还原成模拟的电话信号，最后才能在电话机上听到。 \n\n 对于以太网中的**网关**只能转发三层以上数据包，这一点和路由是一样的。而不同的是**网关**中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。","source":"_posts/backend/计算机网络.md","raw":"---\ntitle: 计算机网络\ndate: 2021-03-27 23:13:11\ntags: \n - CS\ncategories: \n -  ComputerScience\n---\n# 计算机网络\n### url解析返回\n\n1. ip解析:缓存(浏览器和操作系统)-/etc/hosts-根域名-顶级域名-权威(二级)域名\n\n2. 网络层 ip协议 arp协议 mac地址查询\n\n3. 传输层 TCP 连接：TCP 三次握手\n\n4. 应用层 HTTP 连接: 发送 HTTP 请求\n\n5. cdn直接返回/非cdn服务器监听对应端口 处理请求\n\n6. 七层nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口\n\n7. k8s、docker监听端口处理\n\n8. python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn\n\n9. 框架处理（flask/django/fastapi）解析http报文 \n\n10. 查询redis缓存/mysql\n\n11. 组装数据并返回 HTTP 报文 json/text/file返回\n\n12. 浏览器解析渲染页面/前端直接处理的json/xml数据\n\n13. 断开连接：TCP 四次挥手\n\n    \n\n### 网络协议\n\n1.host里面找ip没有从dns里面找\n\n2.请求ip地址 建立连接、nginx静态模板->WSGI服务器 gunicorn ->flask web application -> 返回\n\n\n\n- **应用层** FTP、DNS、Telnet、SMTP、HTTP\n- 表示层  数据压缩，数据加密以及数据描述\n- 会话层   DNS\n- **传输层** tcp、udp\n- **网络层** ip、ARP\n- **数据链路层** PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） \n- **物理层** IEEE   （中继器，集线器，网关）\n\n\n\n### ARP协议\n\n**即地址解析协议（Address Resolution Protocol）， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址**。\n\n基于功能来考虑，ARP是链路层协议；基于分层/包封装来考虑，ARP是网络层协议。\n\n\n\n### Rpc/http区别\n\n**http**:**有用信息占比少**，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是**效率低**，还是因为第七层的缘故.\n\n基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。\n\n\n\n### DNS\n\n\n\n### Tcp **三次握手**\n\n\n\n其中ACK报文是用来应答的，SYN报文是用来同步的\n\n\n\n**作用**：确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备\n\n第一次、第二次不携带数据，防止恶意攻击\n\n\n\n 第一次握手：[客户端]()发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； \n\n 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； \n\n 第三次握手：[客户端]()收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，[客户端]()和服务器进入ESTABLISHED状态，完成三次握手。 \n\n 握手过程中传送的包里不包含数据，三次握手完毕后，[客户端]()与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 \n\n###  Tcp四次挥手\n\n 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。 \n\n 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 \n\n 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。\n 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。\n 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。\n\n###  交换机\n\n 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。 \n\n 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。 \n\n 交换机被广泛应用于二层网络交换，俗称“二层交换机”。 \n\n 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。 \n\n### 路由器  \n\n **路由器**（**Router**）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 \n\n **路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。** 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 \n\n\n\n### 网关 \n\n **网关**（Gateway），**网关**顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 \n\n 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。 \n\n 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 \n\n **网关**是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过**网关**还原成模拟的电话信号，最后才能在电话机上听到。 \n\n 对于以太网中的**网关**只能转发三层以上数据包，这一点和路由是一样的。而不同的是**网关**中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。","slug":"backend/计算机网络","published":1,"updated":"2021-03-27T15:28:03.028Z","_id":"ckmrvzlqq0009pw82cc1e4fuu","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><h3 id=\"url解析返回\"><a href=\"#url解析返回\" class=\"headerlink\" title=\"url解析返回\"></a>url解析返回</h3><ol>\n<li><p>ip解析:缓存(浏览器和操作系统)-/etc/hosts-根域名-顶级域名-权威(二级)域名</p>\n</li>\n<li><p>网络层 ip协议 arp协议 mac地址查询</p>\n</li>\n<li><p>传输层 TCP 连接：TCP 三次握手</p>\n</li>\n<li><p>应用层 HTTP 连接: 发送 HTTP 请求</p>\n</li>\n<li><p>cdn直接返回/非cdn服务器监听对应端口 处理请求</p>\n</li>\n<li><p>七层nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口</p>\n</li>\n<li><p>k8s、docker监听端口处理</p>\n</li>\n<li><p>python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn</p>\n</li>\n<li><p>框架处理（flask/django/fastapi）解析http报文 </p>\n</li>\n<li><p>查询redis缓存/mysql</p>\n</li>\n<li><p>组装数据并返回 HTTP 报文 json/text/file返回</p>\n</li>\n<li><p>浏览器解析渲染页面/前端直接处理的json/xml数据</p>\n</li>\n<li><p>断开连接：TCP 四次挥手</p>\n</li>\n</ol>\n<h3 id=\"网络协议\"><a href=\"#网络协议\" class=\"headerlink\" title=\"网络协议\"></a>网络协议</h3><p>1.host里面找ip没有从dns里面找</p>\n<p>2.请求ip地址 建立连接、nginx静态模板-&gt;WSGI服务器 gunicorn -&gt;flask web application -&gt; 返回</p>\n<ul>\n<li><strong>应用层</strong> FTP、DNS、Telnet、SMTP、HTTP</li>\n<li>表示层  数据压缩，数据加密以及数据描述</li>\n<li>会话层   DNS</li>\n<li><strong>传输层</strong> tcp、udp</li>\n<li><strong>网络层</strong> ip、ARP</li>\n<li><strong>数据链路层</strong> PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） </li>\n<li><strong>物理层</strong> IEEE   （中继器，集线器，网关）</li>\n</ul>\n<h3 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h3><p><strong>即地址解析协议（Address Resolution Protocol）， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址</strong>。</p>\n<p>基于功能来考虑，ARP是链路层协议；基于分层/包封装来考虑，ARP是网络层协议。</p>\n<h3 id=\"Rpc-http区别\"><a href=\"#Rpc-http区别\" class=\"headerlink\" title=\"Rpc/http区别\"></a>Rpc/http区别</h3><p><strong>http</strong>:<strong>有用信息占比少</strong>，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是<strong>效率低</strong>，还是因为第七层的缘故.</p>\n<p>基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。</p>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><h3 id=\"Tcp-三次握手\"><a href=\"#Tcp-三次握手\" class=\"headerlink\" title=\"Tcp 三次握手\"></a>Tcp <strong>三次握手</strong></h3><p>其中ACK报文是用来应答的，SYN报文是用来同步的</p>\n<p><strong>作用</strong>：确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</p>\n<p>第一次、第二次不携带数据，防止恶意攻击</p>\n<p> 第一次握手：<a href=\"\">客户端</a>发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； </p>\n<p> 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； </p>\n<p> 第三次握手：<a href=\"\">客户端</a>收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，<a href=\"\">客户端</a>和服务器进入ESTABLISHED状态，完成三次握手。 </p>\n<p> 握手过程中传送的包里不包含数据，三次握手完毕后，<a href=\"\">客户端</a>与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 </p>\n<h3 id=\"Tcp四次挥手\"><a href=\"#Tcp四次挥手\" class=\"headerlink\" title=\"Tcp四次挥手\"></a>Tcp四次挥手</h3><p> 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。 </p>\n<p> 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 </p>\n<p> 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br> 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。<br> 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>\n<h3 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h3><p> 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。 </p>\n<p> 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。 </p>\n<p> 交换机被广泛应用于二层网络交换，俗称“二层交换机”。 </p>\n<p> 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。 </p>\n<h3 id=\"路由器\"><a href=\"#路由器\" class=\"headerlink\" title=\"路由器\"></a>路由器</h3><p> <strong>路由器</strong>（<strong>Router</strong>）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 </p>\n<p> <strong>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</strong> 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 </p>\n<h3 id=\"网关\"><a href=\"#网关\" class=\"headerlink\" title=\"网关\"></a>网关</h3><p> <strong>网关</strong>（Gateway），<strong>网关</strong>顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 </p>\n<p> 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。 </p>\n<p> 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 </p>\n<p> <strong>网关</strong>是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过<strong>网关</strong>还原成模拟的电话信号，最后才能在电话机上听到。 </p>\n<p> 对于以太网中的<strong>网关</strong>只能转发三层以上数据包，这一点和路由是一样的。而不同的是<strong>网关</strong>中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"计算机网络\"><a href=\"#计算机网络\" class=\"headerlink\" title=\"计算机网络\"></a>计算机网络</h1><h3 id=\"url解析返回\"><a href=\"#url解析返回\" class=\"headerlink\" title=\"url解析返回\"></a>url解析返回</h3><ol>\n<li><p>ip解析:缓存(浏览器和操作系统)-/etc/hosts-根域名-顶级域名-权威(二级)域名</p>\n</li>\n<li><p>网络层 ip协议 arp协议 mac地址查询</p>\n</li>\n<li><p>传输层 TCP 连接：TCP 三次握手</p>\n</li>\n<li><p>应用层 HTTP 连接: 发送 HTTP 请求</p>\n</li>\n<li><p>cdn直接返回/非cdn服务器监听对应端口 处理请求</p>\n</li>\n<li><p>七层nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口</p>\n</li>\n<li><p>k8s、docker监听端口处理</p>\n</li>\n<li><p>python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn</p>\n</li>\n<li><p>框架处理（flask/django/fastapi）解析http报文 </p>\n</li>\n<li><p>查询redis缓存/mysql</p>\n</li>\n<li><p>组装数据并返回 HTTP 报文 json/text/file返回</p>\n</li>\n<li><p>浏览器解析渲染页面/前端直接处理的json/xml数据</p>\n</li>\n<li><p>断开连接：TCP 四次挥手</p>\n</li>\n</ol>\n<h3 id=\"网络协议\"><a href=\"#网络协议\" class=\"headerlink\" title=\"网络协议\"></a>网络协议</h3><p>1.host里面找ip没有从dns里面找</p>\n<p>2.请求ip地址 建立连接、nginx静态模板-&gt;WSGI服务器 gunicorn -&gt;flask web application -&gt; 返回</p>\n<ul>\n<li><strong>应用层</strong> FTP、DNS、Telnet、SMTP、HTTP</li>\n<li>表示层  数据压缩，数据加密以及数据描述</li>\n<li>会话层   DNS</li>\n<li><strong>传输层</strong> tcp、udp</li>\n<li><strong>网络层</strong> ip、ARP</li>\n<li><strong>数据链路层</strong> PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） </li>\n<li><strong>物理层</strong> IEEE   （中继器，集线器，网关）</li>\n</ul>\n<h3 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h3><p><strong>即地址解析协议（Address Resolution Protocol）， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址</strong>。</p>\n<p>基于功能来考虑，ARP是链路层协议；基于分层/包封装来考虑，ARP是网络层协议。</p>\n<h3 id=\"Rpc-http区别\"><a href=\"#Rpc-http区别\" class=\"headerlink\" title=\"Rpc/http区别\"></a>Rpc/http区别</h3><p><strong>http</strong>:<strong>有用信息占比少</strong>，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是<strong>效率低</strong>，还是因为第七层的缘故.</p>\n<p>基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。</p>\n<h3 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h3><h3 id=\"Tcp-三次握手\"><a href=\"#Tcp-三次握手\" class=\"headerlink\" title=\"Tcp 三次握手\"></a>Tcp <strong>三次握手</strong></h3><p>其中ACK报文是用来应答的，SYN报文是用来同步的</p>\n<p><strong>作用</strong>：确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备</p>\n<p>第一次、第二次不携带数据，防止恶意攻击</p>\n<p> 第一次握手：<a href=\"\">客户端</a>发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认； </p>\n<p> 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； </p>\n<p> 第三次握手：<a href=\"\">客户端</a>收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，<a href=\"\">客户端</a>和服务器进入ESTABLISHED状态，完成三次握手。 </p>\n<p> 握手过程中传送的包里不包含数据，三次握手完毕后，<a href=\"\">客户端</a>与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。 </p>\n<h3 id=\"Tcp四次挥手\"><a href=\"#Tcp四次挥手\" class=\"headerlink\" title=\"Tcp四次挥手\"></a>Tcp四次挥手</h3><p> 与建立连接的“三次握手”类似，断开一个TCP连接则需要“四次挥手”。 </p>\n<p> 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 </p>\n<p> 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。<br> 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。<br> 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p>\n<h3 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h3><p> 在计算机网络系统中，交换机是针对共享工作模式的弱点而推出的。交换机拥有一条高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背 部总线上，当控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部 交换矩阵迅速将数据包传送到目的端口。目的MAC若不存在，交换机才广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部地址表 中。 </p>\n<p> 交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP协议学习它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。 </p>\n<p> 交换机被广泛应用于二层网络交换，俗称“二层交换机”。 </p>\n<p> 交换机的种类有：二层交换机、三层交换机、四层交换机、七层交换机分别工作在OSI七层模型中的第二层、第三层、第四层盒第七层，并因此而得名。 </p>\n<h3 id=\"路由器\"><a href=\"#路由器\" class=\"headerlink\" title=\"路由器\"></a>路由器</h3><p> <strong>路由器</strong>（<strong>Router</strong>）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 </p>\n<p> <strong>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。</strong> 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 </p>\n<h3 id=\"网关\"><a href=\"#网关\" class=\"headerlink\" title=\"网关\"></a>网关</h3><p> <strong>网关</strong>（Gateway），<strong>网关</strong>顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。 </p>\n<p> 在传统TCP/IP术语中，网络设备只分成两种，一种为网关（gateway），另一种为主机（host）。网关能在网络间转递数据包，但主机不能 转送数据包。在主机（又称终端系统，end system）中，数据包需经过TCP/IP四层协议处理，但是在网关（又称中介系 统，intermediate system）只需要到达网际层（Internet layer），决定路径之后就可以转送。在当时，网关 （gateway）与路由器（router）还没有区别。 </p>\n<p> 在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。 </p>\n<p> <strong>网关</strong>是连接两个网络的设备，对于语音网关来说，他可以连接PSTN网络和以太网，这就相当于VOIP，把不同电话中的模拟信号通过网关而转换成数字信号，而且加入协议再去传输。在到了接收端的时候再通过<strong>网关</strong>还原成模拟的电话信号，最后才能在电话机上听到。 </p>\n<p> 对于以太网中的<strong>网关</strong>只能转发三层以上数据包，这一点和路由是一样的。而不同的是<strong>网关</strong>中并没有路由表，他只能按照预先设定的不同网段来进行转发。网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。</p>\n"},{"title":"阿里外包（Python）笔试题","date":"2021-03-29T02:19:24.419Z","_content":"\n### 1.linux\n\n```shell\nll -h\nmkdir\ncd\nscp\nhtop\niftop\ntail -f app.log\nvi XX.\nlsof -i:80\nping\ntelnet ip port\nyum install\nps -ef|grep python\nkillall <PROCRESS>\nkill -9 <PID>\nssh root@<HOST>\ncurl <>\nchmod 777 <>\nln -s <> <> \n```\n\ncat filename.log |grep 'login'|wc -l\n\n### 2.SQL\n\n```mysql\nselect distinct name from student  where score>95;\nselect count(distinct name)  from student  where score>95;\nselect count(1) as ct,socre from student group by  socre order by ct desc \n```\n\n### 3.编码\n\n#### 数组操作\n\n```python\ndef array_insert(array, n):\n    for index, key in enumerate(array):\n        if n <= key:\n            return index\n    return len(array)\n```\n\n\n\n#### 多线程锁及通信\n\n```python\nimport threading\n\n\ndef target_a(counter=10):\n    while counter:\n        locka.acquire()\n        print('a', end='')\n        lockb.release()\n        counter -= 1\n\n\ndef target_b(counter=10):\n    while counter:\n        lockb.acquire()\n        print('b', end='')\n        lockc.release()\n        counter -= 1\n\n\ndef target_c(counter=10):\n    while counter:\n        lockc.acquire()\n        print('c', end='')\n        locka.release()\n        counter -= 1\n\n\nif __name__ == '__main__':\n    locka = threading.Lock()\n    lockb = threading.Lock()\n    lockc = threading.Lock()\n\n    lockb.acquire()\n    lockc.acquire()\n\n    t1 = threading.Thread(target=target_a)\n    t2 = threading.Thread(target=target_b)\n    t3 = threading.Thread(target=target_c)\n\n    t1.start()\n    t2.start()\n    t3.start()\n```\n\n\n\n#### 快排 \n\n```python\ndef quick_sort(lt):\n    if len(lt) <= 1:\n        return lt\n    mid = lt[len(lt) // 2]\n    lt.remove(mid)\n    left_lt, right_lt = [], []\n    for i in lt:\n        if i <= mid:\n            left_lt.append(i)\n        if i > mid:\n            right_lt.append(i)\n    return quick_sort(left_lt) + [mid] + quick_sort(right_lt)\n```\n\n#### 找两数之和\n\n```python\ndef find_sum(lt, n):\n    dt = {i: e for e, i in enumerate(lt) if n - i <= i}\n    res = []\n    for e, i in enumerate(lt):\n        if n - i in dt:\n            if e != dt[n - i]:\n                res.append([n - i, i])\n    return res\n\n\nif __name__ == '__main__':\n    r = find_sum([0, 1, 3, 9, 7, 2, 8, 4, 5, 5], 10)\n    print(r)\n```\n\n\n\n### 发散题\n\n#### 接口耗时长-排查及优化\n\ntime.time()打点找出运行慢的那一块代码，然后具体问题具体分析\n\n##### 问题处理\n\n- **代码bug**: 修bug\n\n- **多个IO请求等待:** 开多线程池请求\n\n- **cpu密集型计算：** 考虑开多进程处理或者c++重写 py调用\n\n- **数据库查询慢:**\n\n  - 用explain 看走没走索引 没有的话 对应字段 建索引 force index 强制走索引查询\n\n  - 数据库内存 cpu压力不正常 查看占用高的sql 优化 或者升级 \n\n  - 查看show processlist 查看是不是有过多或者慢查询占用内存和cpu 再kill\n\n  -  ddl语句锁表表结构重构中导致不能查询 \n\n  - sql语句优化 减少like join表  !=，乱建索引，select *\n\n    \n\n##### 优化\n\n- 消息队列 与接口返回无关的一系列操作可以考虑异步 redis或者mq消息队列处理，单生产者接入多消费者\n- redis加缓存 \n\n\n\n#### Url请求返回\n\n1. url解析成ip : /etc/hosts + DNS\n2. 网络层 ip协议 arp协议 mac地址查询\n3. 传输层 TCP 连接：TCP 三次握手\n4. 应用层 HTTP 连接: 发送 HTTP 请求\n5. 服务器监听对应端口 处理请求\n6. nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口\n7. k8s、docker监听端口处理\n8. python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn\n9. 框架处理（flask/django/fastapi）解析http报文 json/text/file返回\n10. 查询redis缓存/mysql\n11. 组装数据并返回 HTTP 报文\n12. 浏览器解析渲染页面/前端直接处理的json/xml数据\n13. 断开连接：TCP 四次挥手\n\n\n","source":"_posts/阿里外包.md","raw":"---\ntitle: 阿里外包（Python）笔试题\ndate: 2021-03-29 10:20:00P\ntags: \n - 面试\n - Python\ncategories: \n - 面试\n---\n\n### 1.linux\n\n```shell\nll -h\nmkdir\ncd\nscp\nhtop\niftop\ntail -f app.log\nvi XX.\nlsof -i:80\nping\ntelnet ip port\nyum install\nps -ef|grep python\nkillall <PROCRESS>\nkill -9 <PID>\nssh root@<HOST>\ncurl <>\nchmod 777 <>\nln -s <> <> \n```\n\ncat filename.log |grep 'login'|wc -l\n\n### 2.SQL\n\n```mysql\nselect distinct name from student  where score>95;\nselect count(distinct name)  from student  where score>95;\nselect count(1) as ct,socre from student group by  socre order by ct desc \n```\n\n### 3.编码\n\n#### 数组操作\n\n```python\ndef array_insert(array, n):\n    for index, key in enumerate(array):\n        if n <= key:\n            return index\n    return len(array)\n```\n\n\n\n#### 多线程锁及通信\n\n```python\nimport threading\n\n\ndef target_a(counter=10):\n    while counter:\n        locka.acquire()\n        print('a', end='')\n        lockb.release()\n        counter -= 1\n\n\ndef target_b(counter=10):\n    while counter:\n        lockb.acquire()\n        print('b', end='')\n        lockc.release()\n        counter -= 1\n\n\ndef target_c(counter=10):\n    while counter:\n        lockc.acquire()\n        print('c', end='')\n        locka.release()\n        counter -= 1\n\n\nif __name__ == '__main__':\n    locka = threading.Lock()\n    lockb = threading.Lock()\n    lockc = threading.Lock()\n\n    lockb.acquire()\n    lockc.acquire()\n\n    t1 = threading.Thread(target=target_a)\n    t2 = threading.Thread(target=target_b)\n    t3 = threading.Thread(target=target_c)\n\n    t1.start()\n    t2.start()\n    t3.start()\n```\n\n\n\n#### 快排 \n\n```python\ndef quick_sort(lt):\n    if len(lt) <= 1:\n        return lt\n    mid = lt[len(lt) // 2]\n    lt.remove(mid)\n    left_lt, right_lt = [], []\n    for i in lt:\n        if i <= mid:\n            left_lt.append(i)\n        if i > mid:\n            right_lt.append(i)\n    return quick_sort(left_lt) + [mid] + quick_sort(right_lt)\n```\n\n#### 找两数之和\n\n```python\ndef find_sum(lt, n):\n    dt = {i: e for e, i in enumerate(lt) if n - i <= i}\n    res = []\n    for e, i in enumerate(lt):\n        if n - i in dt:\n            if e != dt[n - i]:\n                res.append([n - i, i])\n    return res\n\n\nif __name__ == '__main__':\n    r = find_sum([0, 1, 3, 9, 7, 2, 8, 4, 5, 5], 10)\n    print(r)\n```\n\n\n\n### 发散题\n\n#### 接口耗时长-排查及优化\n\ntime.time()打点找出运行慢的那一块代码，然后具体问题具体分析\n\n##### 问题处理\n\n- **代码bug**: 修bug\n\n- **多个IO请求等待:** 开多线程池请求\n\n- **cpu密集型计算：** 考虑开多进程处理或者c++重写 py调用\n\n- **数据库查询慢:**\n\n  - 用explain 看走没走索引 没有的话 对应字段 建索引 force index 强制走索引查询\n\n  - 数据库内存 cpu压力不正常 查看占用高的sql 优化 或者升级 \n\n  - 查看show processlist 查看是不是有过多或者慢查询占用内存和cpu 再kill\n\n  -  ddl语句锁表表结构重构中导致不能查询 \n\n  - sql语句优化 减少like join表  !=，乱建索引，select *\n\n    \n\n##### 优化\n\n- 消息队列 与接口返回无关的一系列操作可以考虑异步 redis或者mq消息队列处理，单生产者接入多消费者\n- redis加缓存 \n\n\n\n#### Url请求返回\n\n1. url解析成ip : /etc/hosts + DNS\n2. 网络层 ip协议 arp协议 mac地址查询\n3. 传输层 TCP 连接：TCP 三次握手\n4. 应用层 HTTP 连接: 发送 HTTP 请求\n5. 服务器监听对应端口 处理请求\n6. nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口\n7. k8s、docker监听端口处理\n8. python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn\n9. 框架处理（flask/django/fastapi）解析http报文 json/text/file返回\n10. 查询redis缓存/mysql\n11. 组装数据并返回 HTTP 报文\n12. 浏览器解析渲染页面/前端直接处理的json/xml数据\n13. 断开连接：TCP 四次挥手\n\n\n","slug":"阿里外包","published":1,"updated":"2021-03-29T02:28:01.925Z","_id":"ckmtyu7ka0000tf82dcs8768b","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"1-linux\"><a href=\"#1-linux\" class=\"headerlink\" title=\"1.linux\"></a>1.linux</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ll -h<br>mkdir<br>cd<br>scp<br>htop<br>iftop<br>tail -f app.log<br>vi XX.<br>lsof -i:80<br>ping<br>telnet ip port<br>yum install<br>ps -ef|grep python<br>killall &lt;PROCRESS&gt;<br>kill -9 &lt;PID&gt;<br>ssh root@&lt;HOST&gt;<br>curl &lt;&gt;<br>chmod 777 &lt;&gt;<br>ln -s &lt;&gt; &lt;&gt; <br></code></pre></td></tr></table></figure>\n\n<p>cat filename.log |grep ‘login’|wc -l</p>\n<h3 id=\"2-SQL\"><a href=\"#2-SQL\" class=\"headerlink\" title=\"2.SQL\"></a>2.SQL</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select distinct name from student  where score&gt;95;<br>select count(distinct name)  from student  where score&gt;95;<br>select count(1) as ct,socre from student group by  socre order by ct desc <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-编码\"><a href=\"#3-编码\" class=\"headerlink\" title=\"3.编码\"></a>3.编码</h3><h4 id=\"数组操作\"><a href=\"#数组操作\" class=\"headerlink\" title=\"数组操作\"></a>数组操作</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">array_insert</span>(<span class=\"hljs-params\">array, n</span>):</span><br>    <span class=\"hljs-keyword\">for</span> index, key <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(array):<br>        <span class=\"hljs-keyword\">if</span> n &lt;= key:<br>            <span class=\"hljs-keyword\">return</span> index<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(array)<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"多线程锁及通信\"><a href=\"#多线程锁及通信\" class=\"headerlink\" title=\"多线程锁及通信\"></a>多线程锁及通信</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> threading<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">target_a</span>(<span class=\"hljs-params\">counter=<span class=\"hljs-number\">10</span></span>):</span><br>    <span class=\"hljs-keyword\">while</span> counter:<br>        locka.acquire()<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, end=<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>        lockb.release()<br>        counter -= <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">target_b</span>(<span class=\"hljs-params\">counter=<span class=\"hljs-number\">10</span></span>):</span><br>    <span class=\"hljs-keyword\">while</span> counter:<br>        lockb.acquire()<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, end=<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>        lockc.release()<br>        counter -= <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">target_c</span>(<span class=\"hljs-params\">counter=<span class=\"hljs-number\">10</span></span>):</span><br>    <span class=\"hljs-keyword\">while</span> counter:<br>        lockc.acquire()<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, end=<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>        locka.release()<br>        counter -= <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    locka = threading.Lock()<br>    lockb = threading.Lock()<br>    lockc = threading.Lock()<br><br>    lockb.acquire()<br>    lockc.acquire()<br><br>    t1 = threading.Thread(target=target_a)<br>    t2 = threading.Thread(target=target_b)<br>    t3 = threading.Thread(target=target_c)<br><br>    t1.start()<br>    t2.start()<br>    t3.start()<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">quick_sort</span>(<span class=\"hljs-params\">lt</span>):</span><br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(lt) &lt;= <span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> lt<br>    mid = lt[<span class=\"hljs-built_in\">len</span>(lt) // <span class=\"hljs-number\">2</span>]<br>    lt.remove(mid)<br>    left_lt, right_lt = [], []<br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> lt:<br>        <span class=\"hljs-keyword\">if</span> i &lt;= mid:<br>            left_lt.append(i)<br>        <span class=\"hljs-keyword\">if</span> i &gt; mid:<br>            right_lt.append(i)<br>    <span class=\"hljs-keyword\">return</span> quick_sort(left_lt) + [mid] + quick_sort(right_lt)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"找两数之和\"><a href=\"#找两数之和\" class=\"headerlink\" title=\"找两数之和\"></a>找两数之和</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">find_sum</span>(<span class=\"hljs-params\">lt, n</span>):</span><br>    dt = &#123;i: e <span class=\"hljs-keyword\">for</span> e, i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(lt) <span class=\"hljs-keyword\">if</span> n - i &lt;= i&#125;<br>    res = []<br>    <span class=\"hljs-keyword\">for</span> e, i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(lt):<br>        <span class=\"hljs-keyword\">if</span> n - i <span class=\"hljs-keyword\">in</span> dt:<br>            <span class=\"hljs-keyword\">if</span> e != dt[n - i]:<br>                res.append([n - i, i])<br>    <span class=\"hljs-keyword\">return</span> res<br><br><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    r = find_sum([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>], <span class=\"hljs-number\">10</span>)<br>    <span class=\"hljs-built_in\">print</span>(r)<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"发散题\"><a href=\"#发散题\" class=\"headerlink\" title=\"发散题\"></a>发散题</h3><h4 id=\"接口耗时长-排查及优化\"><a href=\"#接口耗时长-排查及优化\" class=\"headerlink\" title=\"接口耗时长-排查及优化\"></a>接口耗时长-排查及优化</h4><p>time.time()打点找出运行慢的那一块代码，然后具体问题具体分析</p>\n<h5 id=\"问题处理\"><a href=\"#问题处理\" class=\"headerlink\" title=\"问题处理\"></a>问题处理</h5><ul>\n<li><p><strong>代码bug</strong>: 修bug</p>\n</li>\n<li><p><strong>多个IO请求等待:</strong> 开多线程池请求</p>\n</li>\n<li><p><strong>cpu密集型计算：</strong> 考虑开多进程处理或者c++重写 py调用</p>\n</li>\n<li><p><strong>数据库查询慢:</strong></p>\n<ul>\n<li><p>用explain 看走没走索引 没有的话 对应字段 建索引 force index 强制走索引查询</p>\n</li>\n<li><p>数据库内存 cpu压力不正常 查看占用高的sql 优化 或者升级 </p>\n</li>\n<li><p>查看show processlist 查看是不是有过多或者慢查询占用内存和cpu 再kill</p>\n</li>\n<li><p> ddl语句锁表表结构重构中导致不能查询 </p>\n</li>\n<li><p>sql语句优化 减少like join表  !=，乱建索引，select *</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><ul>\n<li>消息队列 与接口返回无关的一系列操作可以考虑异步 redis或者mq消息队列处理，单生产者接入多消费者</li>\n<li>redis加缓存 </li>\n</ul>\n<h4 id=\"Url请求返回\"><a href=\"#Url请求返回\" class=\"headerlink\" title=\"Url请求返回\"></a>Url请求返回</h4><ol>\n<li>url解析成ip : /etc/hosts + DNS</li>\n<li>网络层 ip协议 arp协议 mac地址查询</li>\n<li>传输层 TCP 连接：TCP 三次握手</li>\n<li>应用层 HTTP 连接: 发送 HTTP 请求</li>\n<li>服务器监听对应端口 处理请求</li>\n<li>nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口</li>\n<li>k8s、docker监听端口处理</li>\n<li>python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn</li>\n<li>框架处理（flask/django/fastapi）解析http报文 json/text/file返回</li>\n<li>查询redis缓存/mysql</li>\n<li>组装数据并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面/前端直接处理的json/xml数据</li>\n<li>断开连接：TCP 四次挥手</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"1-linux\"><a href=\"#1-linux\" class=\"headerlink\" title=\"1.linux\"></a>1.linux</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ll -h<br>mkdir<br>cd<br>scp<br>htop<br>iftop<br>tail -f app.log<br>vi XX.<br>lsof -i:80<br>ping<br>telnet ip port<br>yum install<br>ps -ef|grep python<br>killall &lt;PROCRESS&gt;<br>kill -9 &lt;PID&gt;<br>ssh root@&lt;HOST&gt;<br>curl &lt;&gt;<br>chmod 777 &lt;&gt;<br>ln -s &lt;&gt; &lt;&gt; <br></code></pre></td></tr></table></figure>\n\n<p>cat filename.log |grep ‘login’|wc -l</p>\n<h3 id=\"2-SQL\"><a href=\"#2-SQL\" class=\"headerlink\" title=\"2.SQL\"></a>2.SQL</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select distinct name from student  where score&gt;95;<br>select count(distinct name)  from student  where score&gt;95;<br>select count(1) as ct,socre from student group by  socre order by ct desc <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-编码\"><a href=\"#3-编码\" class=\"headerlink\" title=\"3.编码\"></a>3.编码</h3><h4 id=\"数组操作\"><a href=\"#数组操作\" class=\"headerlink\" title=\"数组操作\"></a>数组操作</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">array_insert</span>(<span class=\"hljs-params\">array, n</span>):</span><br>    <span class=\"hljs-keyword\">for</span> index, key <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(array):<br>        <span class=\"hljs-keyword\">if</span> n &lt;= key:<br>            <span class=\"hljs-keyword\">return</span> index<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">len</span>(array)<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"多线程锁及通信\"><a href=\"#多线程锁及通信\" class=\"headerlink\" title=\"多线程锁及通信\"></a>多线程锁及通信</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> threading<br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">target_a</span>(<span class=\"hljs-params\">counter=<span class=\"hljs-number\">10</span></span>):</span><br>    <span class=\"hljs-keyword\">while</span> counter:<br>        locka.acquire()<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, end=<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>        lockb.release()<br>        counter -= <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">target_b</span>(<span class=\"hljs-params\">counter=<span class=\"hljs-number\">10</span></span>):</span><br>    <span class=\"hljs-keyword\">while</span> counter:<br>        lockb.acquire()<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, end=<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>        lockc.release()<br>        counter -= <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">target_c</span>(<span class=\"hljs-params\">counter=<span class=\"hljs-number\">10</span></span>):</span><br>    <span class=\"hljs-keyword\">while</span> counter:<br>        lockc.acquire()<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, end=<span class=\"hljs-string\">&#x27;&#x27;</span>)<br>        locka.release()<br>        counter -= <span class=\"hljs-number\">1</span><br><br><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    locka = threading.Lock()<br>    lockb = threading.Lock()<br>    lockc = threading.Lock()<br><br>    lockb.acquire()<br>    lockc.acquire()<br><br>    t1 = threading.Thread(target=target_a)<br>    t2 = threading.Thread(target=target_b)<br>    t3 = threading.Thread(target=target_c)<br><br>    t1.start()<br>    t2.start()<br>    t3.start()<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"快排\"><a href=\"#快排\" class=\"headerlink\" title=\"快排\"></a>快排</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">quick_sort</span>(<span class=\"hljs-params\">lt</span>):</span><br>    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(lt) &lt;= <span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">return</span> lt<br>    mid = lt[<span class=\"hljs-built_in\">len</span>(lt) // <span class=\"hljs-number\">2</span>]<br>    lt.remove(mid)<br>    left_lt, right_lt = [], []<br>    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> lt:<br>        <span class=\"hljs-keyword\">if</span> i &lt;= mid:<br>            left_lt.append(i)<br>        <span class=\"hljs-keyword\">if</span> i &gt; mid:<br>            right_lt.append(i)<br>    <span class=\"hljs-keyword\">return</span> quick_sort(left_lt) + [mid] + quick_sort(right_lt)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"找两数之和\"><a href=\"#找两数之和\" class=\"headerlink\" title=\"找两数之和\"></a>找两数之和</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">find_sum</span>(<span class=\"hljs-params\">lt, n</span>):</span><br>    dt = &#123;i: e <span class=\"hljs-keyword\">for</span> e, i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(lt) <span class=\"hljs-keyword\">if</span> n - i &lt;= i&#125;<br>    res = []<br>    <span class=\"hljs-keyword\">for</span> e, i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(lt):<br>        <span class=\"hljs-keyword\">if</span> n - i <span class=\"hljs-keyword\">in</span> dt:<br>            <span class=\"hljs-keyword\">if</span> e != dt[n - i]:<br>                res.append([n - i, i])<br>    <span class=\"hljs-keyword\">return</span> res<br><br><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&#x27;__main__&#x27;</span>:<br>    r = find_sum([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">5</span>], <span class=\"hljs-number\">10</span>)<br>    <span class=\"hljs-built_in\">print</span>(r)<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"发散题\"><a href=\"#发散题\" class=\"headerlink\" title=\"发散题\"></a>发散题</h3><h4 id=\"接口耗时长-排查及优化\"><a href=\"#接口耗时长-排查及优化\" class=\"headerlink\" title=\"接口耗时长-排查及优化\"></a>接口耗时长-排查及优化</h4><p>time.time()打点找出运行慢的那一块代码，然后具体问题具体分析</p>\n<h5 id=\"问题处理\"><a href=\"#问题处理\" class=\"headerlink\" title=\"问题处理\"></a>问题处理</h5><ul>\n<li><p><strong>代码bug</strong>: 修bug</p>\n</li>\n<li><p><strong>多个IO请求等待:</strong> 开多线程池请求</p>\n</li>\n<li><p><strong>cpu密集型计算：</strong> 考虑开多进程处理或者c++重写 py调用</p>\n</li>\n<li><p><strong>数据库查询慢:</strong></p>\n<ul>\n<li><p>用explain 看走没走索引 没有的话 对应字段 建索引 force index 强制走索引查询</p>\n</li>\n<li><p>数据库内存 cpu压力不正常 查看占用高的sql 优化 或者升级 </p>\n</li>\n<li><p>查看show processlist 查看是不是有过多或者慢查询占用内存和cpu 再kill</p>\n</li>\n<li><p> ddl语句锁表表结构重构中导致不能查询 </p>\n</li>\n<li><p>sql语句优化 减少like join表  !=，乱建索引，select *</p>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h5><ul>\n<li>消息队列 与接口返回无关的一系列操作可以考虑异步 redis或者mq消息队列处理，单生产者接入多消费者</li>\n<li>redis加缓存 </li>\n</ul>\n<h4 id=\"Url请求返回\"><a href=\"#Url请求返回\" class=\"headerlink\" title=\"Url请求返回\"></a>Url请求返回</h4><ol>\n<li>url解析成ip : /etc/hosts + DNS</li>\n<li>网络层 ip协议 arp协议 mac地址查询</li>\n<li>传输层 TCP 连接：TCP 三次握手</li>\n<li>应用层 HTTP 连接: 发送 HTTP 请求</li>\n<li>服务器监听对应端口 处理请求</li>\n<li>nginx负载均衡分发 静态页面直接返回 部分动态页面转发到服务器对应端口</li>\n<li>k8s、docker监听端口处理</li>\n<li>python网关服务器处理(ASGI/WSGI)  uWSGI/gunicorn/uvicorn</li>\n<li>框架处理（flask/django/fastapi）解析http报文 json/text/file返回</li>\n<li>查询redis缓存/mysql</li>\n<li>组装数据并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面/前端直接处理的json/xml数据</li>\n<li>断开连接：TCP 四次挥手</li>\n</ol>\n"},{"title":"Redis持久化策略","date":"2021-04-01T08:48:00.000Z","_content":"# Redis持久化策略\n\n### 问题\n\n1.  宕机了，Redis如何避免数据丢失？\n2.  AOF 日志是如何实现的？\n3.  AOF日志过大怎么解决？\n4.  AOF 重写会阻塞吗?\n5.  快照时数据能修改吗?\n6.  相对比较好的持久化策略\n\n\n\n三点建议：\n\n- 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；\n- 如果允许分钟级别的数据丢失，可以只使用 RDB；\n- 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。\n\n\n\n### RDB\n\nRDB(内存快照): 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。\n\n- 相对于大数据集，RDB的启动效率会更高。\n- fork出一个子进程同步数据 子进程共享主进程数, 不阻塞主进程数据，主进程在修改数据时会创建副本 子进程读副本，fork创建会阻塞主进程（涉及内存共享）\n\n\n\n Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。\n\n- **save**：在主线程中执行，会导致阻塞；\n- **bgsave**：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。\n\n![img](https://static001.geekbang.org/resource/image/4d/cc/4dc5fb99a1c94f70957cce1ffef419cc.jpg)\n\n\n\n**但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。**\n\nbgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。 \n\n为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。\n\n\n\n### AOF(Append Only File)\n\nAOF原理是将Reids的操作日志以追加的方式写入文件 。\n\n- 先处理后写，1.避免错误日志 2.不会阻塞操作，3.避免写完日志后宕机\n\n- 通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性\n- AOF 重写不阻塞  后台子进程 bgrewriteaof处理\n\n\n\n\n![img](https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg)\n\n\n#### AOF 配置\n\n- Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘； 影响性能\n- Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；\n- No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。\n\n\n\n#### AOF工作原理\n\n1、Redis 执行 fork() ，现在同时拥有父进程和子进程。\n2、子进程开始将新 AOF 文件的内容写入到临时文件。\n3、对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。\n4、当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。\n5、搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。\n\n\n\n#### AOF 重写\n\n1. auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB\n2. auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。\n\nAOF文件大小同时超出上面这两个配置项时，会触发AOF重写。\n\n\n\n\n![img](https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg)","source":"_posts/redis/Redis持久化策略.md","raw":"---\ntitle: Redis持久化策略\ndate: 2021-04-01 16:48\ntags: \n - Database\n - NoSQL\ncategories: \n - Redis\n---\n# Redis持久化策略\n\n### 问题\n\n1.  宕机了，Redis如何避免数据丢失？\n2.  AOF 日志是如何实现的？\n3.  AOF日志过大怎么解决？\n4.  AOF 重写会阻塞吗?\n5.  快照时数据能修改吗?\n6.  相对比较好的持久化策略\n\n\n\n三点建议：\n\n- 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；\n- 如果允许分钟级别的数据丢失，可以只使用 RDB；\n- 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。\n\n\n\n### RDB\n\nRDB(内存快照): 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。\n\n- 相对于大数据集，RDB的启动效率会更高。\n- fork出一个子进程同步数据 子进程共享主进程数, 不阻塞主进程数据，主进程在修改数据时会创建副本 子进程读副本，fork创建会阻塞主进程（涉及内存共享）\n\n\n\n Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。\n\n- **save**：在主线程中执行，会导致阻塞；\n- **bgsave**：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。\n\n![img](https://static001.geekbang.org/resource/image/4d/cc/4dc5fb99a1c94f70957cce1ffef419cc.jpg)\n\n\n\n**但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。**\n\nbgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。 \n\n为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。\n\n\n\n### AOF(Append Only File)\n\nAOF原理是将Reids的操作日志以追加的方式写入文件 。\n\n- 先处理后写，1.避免错误日志 2.不会阻塞操作，3.避免写完日志后宕机\n\n- 通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性\n- AOF 重写不阻塞  后台子进程 bgrewriteaof处理\n\n\n\n\n![img](https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg)\n\n\n#### AOF 配置\n\n- Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘； 影响性能\n- Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；\n- No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。\n\n\n\n#### AOF工作原理\n\n1、Redis 执行 fork() ，现在同时拥有父进程和子进程。\n2、子进程开始将新 AOF 文件的内容写入到临时文件。\n3、对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。\n4、当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。\n5、搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。\n\n\n\n#### AOF 重写\n\n1. auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB\n2. auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。\n\nAOF文件大小同时超出上面这两个配置项时，会触发AOF重写。\n\n\n\n\n![img](https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg)","slug":"redis/Redis持久化策略","published":1,"updated":"2021-04-01T08:48:30.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmymz1hb0000its6f5b1abw5","content":"<h1 id=\"Redis持久化策略\"><a href=\"#Redis持久化策略\" class=\"headerlink\" title=\"Redis持久化策略\"></a>Redis持久化策略</h1><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li> 宕机了，Redis如何避免数据丢失？</li>\n<li> AOF 日志是如何实现的？</li>\n<li> AOF日志过大怎么解决？</li>\n<li> AOF 重写会阻塞吗?</li>\n<li> 快照时数据能修改吗?</li>\n<li> 相对比较好的持久化策略</li>\n</ol>\n<p>三点建议：</p>\n<ul>\n<li>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；</li>\n<li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li>\n<li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li>\n</ul>\n<h3 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h3><p>RDB(内存快照): 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。</p>\n<ul>\n<li>相对于大数据集，RDB的启动效率会更高。</li>\n<li>fork出一个子进程同步数据 子进程共享主进程数, 不阻塞主进程数据，主进程在修改数据时会创建副本 子进程读副本，fork创建会阻塞主进程（涉及内存共享）</li>\n</ul>\n<p> Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p>\n<ul>\n<li><strong>save</strong>：在主线程中执行，会导致阻塞；</li>\n<li><strong>bgsave</strong>：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/4d/cc/4dc5fb99a1c94f70957cce1ffef419cc.jpg\" alt=\"img\"></p>\n<p><strong>但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</strong></p>\n<p>bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。 </p>\n<p>为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</p>\n<h3 id=\"AOF-Append-Only-File\"><a href=\"#AOF-Append-Only-File\" class=\"headerlink\" title=\"AOF(Append Only File)\"></a>AOF(Append Only File)</h3><p>AOF原理是将Reids的操作日志以追加的方式写入文件 。</p>\n<ul>\n<li><p>先处理后写，1.避免错误日志 2.不会阻塞操作，3.避免写完日志后宕机</p>\n</li>\n<li><p>通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性</p>\n</li>\n<li><p>AOF 重写不阻塞  后台子进程 bgrewriteaof处理</p>\n</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg\" alt=\"img\"></p>\n<h4 id=\"AOF-配置\"><a href=\"#AOF-配置\" class=\"headerlink\" title=\"AOF 配置\"></a>AOF 配置</h4><ul>\n<li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘； 影响性能</li>\n<li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>\n<li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>\n</ul>\n<h4 id=\"AOF工作原理\"><a href=\"#AOF工作原理\" class=\"headerlink\" title=\"AOF工作原理\"></a>AOF工作原理</h4><p>1、Redis 执行 fork() ，现在同时拥有父进程和子进程。<br>2、子进程开始将新 AOF 文件的内容写入到临时文件。<br>3、对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。<br>4、当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。<br>5、搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</p>\n<h4 id=\"AOF-重写\"><a href=\"#AOF-重写\" class=\"headerlink\" title=\"AOF 重写\"></a>AOF 重写</h4><ol>\n<li>auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB</li>\n<li>auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。</li>\n</ol>\n<p>AOF文件大小同时超出上面这两个配置项时，会触发AOF重写。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg\" alt=\"img\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Redis持久化策略\"><a href=\"#Redis持久化策略\" class=\"headerlink\" title=\"Redis持久化策略\"></a>Redis持久化策略</h1><h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li> 宕机了，Redis如何避免数据丢失？</li>\n<li> AOF 日志是如何实现的？</li>\n<li> AOF日志过大怎么解决？</li>\n<li> AOF 重写会阻塞吗?</li>\n<li> 快照时数据能修改吗?</li>\n<li> 相对比较好的持久化策略</li>\n</ol>\n<p>三点建议：</p>\n<ul>\n<li>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；</li>\n<li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li>\n<li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li>\n</ul>\n<h3 id=\"RDB\"><a href=\"#RDB\" class=\"headerlink\" title=\"RDB\"></a>RDB</h3><p>RDB(内存快照): 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。</p>\n<ul>\n<li>相对于大数据集，RDB的启动效率会更高。</li>\n<li>fork出一个子进程同步数据 子进程共享主进程数, 不阻塞主进程数据，主进程在修改数据时会创建副本 子进程读副本，fork创建会阻塞主进程（涉及内存共享）</li>\n</ul>\n<p> Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p>\n<ul>\n<li><strong>save</strong>：在主线程中执行，会导致阻塞；</li>\n<li><strong>bgsave</strong>：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/4d/cc/4dc5fb99a1c94f70957cce1ffef419cc.jpg\" alt=\"img\"></p>\n<p><strong>但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</strong></p>\n<p>bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。 </p>\n<p>为了快照而暂停写操作，肯定是不能接受的。所以这个时候，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</p>\n<h3 id=\"AOF-Append-Only-File\"><a href=\"#AOF-Append-Only-File\" class=\"headerlink\" title=\"AOF(Append Only File)\"></a>AOF(Append Only File)</h3><p>AOF原理是将Reids的操作日志以追加的方式写入文件 。</p>\n<ul>\n<li><p>先处理后写，1.避免错误日志 2.不会阻塞操作，3.避免写完日志后宕机</p>\n</li>\n<li><p>通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性</p>\n</li>\n<li><p>AOF 重写不阻塞  后台子进程 bgrewriteaof处理</p>\n</li>\n</ul>\n<p><img src=\"https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg\" alt=\"img\"></p>\n<h4 id=\"AOF-配置\"><a href=\"#AOF-配置\" class=\"headerlink\" title=\"AOF 配置\"></a>AOF 配置</h4><ul>\n<li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘； 影响性能</li>\n<li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>\n<li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>\n</ul>\n<h4 id=\"AOF工作原理\"><a href=\"#AOF工作原理\" class=\"headerlink\" title=\"AOF工作原理\"></a>AOF工作原理</h4><p>1、Redis 执行 fork() ，现在同时拥有父进程和子进程。<br>2、子进程开始将新 AOF 文件的内容写入到临时文件。<br>3、对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾,这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。<br>4、当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。<br>5、搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。</p>\n<h4 id=\"AOF-重写\"><a href=\"#AOF-重写\" class=\"headerlink\" title=\"AOF 重写\"></a>AOF 重写</h4><ol>\n<li>auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB</li>\n<li>auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。</li>\n</ol>\n<p>AOF文件大小同时超出上面这两个配置项时，会触发AOF重写。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg\" alt=\"img\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckmrvhm9p0000g282evrsfpwd","category_id":"ckmrvj8ka0001g282g55f44c2","_id":"ckmrvj8kg0006g2825sgx7bab"},{"post_id":"ckmrvyjrm0004pw82dlwagn8g","category_id":"ckmrvyxld0005pw82f70yegvt","_id":"ckmrvyxlg0008pw82bt5z29tg"},{"post_id":"ckmrvzlqq0009pw82cc1e4fuu","category_id":"ckmrw16x5000cpw82brda3ydf","_id":"ckmrw16x7000fpw82fgpe05z9"},{"post_id":"ckmrvwj1w0000pw821jru29rx","category_id":"ckmrw16x5000cpw82brda3ydf","_id":"ckmrw16x7000gpw82drgjawye"},{"post_id":"ckmtyu7ka0000tf82dcs8768b","category_id":"ckmtyu7ke0001tf8200yghr86","_id":"ckmtyu7kh0005tf828d93ciwk"},{"post_id":"ckmngmeuz00004qs6gyadfsv7","category_id":"ckmymz1hc0001its685gagi37","_id":"ckmymz1hh0005its61i6v4zb3"},{"post_id":"ckmymz1hb0000its6f5b1abw5","category_id":"ckmymz1hc0001its685gagi37","_id":"ckmymz1hh0006its6a5kj82m7"}],"PostTag":[{"post_id":"ckmngmeuz00004qs6gyadfsv7","tag_id":"ckmnglin0000519s69y5h05t4","_id":"ckmngmev100014qs6226u49yc"},{"post_id":"ckmngmeuz00004qs6gyadfsv7","tag_id":"ckmrvj8ka0002g2827e1kcxmn","_id":"ckmrvj8kb0003g282718q59vz"},{"post_id":"ckmrvhm9p0000g282evrsfpwd","tag_id":"ckmrvj8ka0002g2827e1kcxmn","_id":"ckmrvj8kg0005g2829pbe09b4"},{"post_id":"ckmrvyjrm0004pw82dlwagn8g","tag_id":"ckmrvyxle0006pw826ekgg13f","_id":"ckmrvyxlf0007pw82bcygd79j"},{"post_id":"ckmrvwj1w0000pw821jru29rx","tag_id":"ckmrvzuyz000apw82aak33ly9","_id":"ckmrvzuyz000bpw829qvbd1c7"},{"post_id":"ckmrvzlqq0009pw82cc1e4fuu","tag_id":"ckmrvzuyz000apw82aak33ly9","_id":"ckmrw16x5000dpw82dbny6ddf"},{"post_id":"ckmtyu7ka0000tf82dcs8768b","tag_id":"ckmtyu7kg0002tf82gl4xdfds","_id":"ckmtyu7kh0003tf826s4u13yr"},{"post_id":"ckmtyu7ka0000tf82dcs8768b","tag_id":"ckmrvyxle0006pw826ekgg13f","_id":"ckmtyu7kh0004tf82125f5lkg"},{"post_id":"ckmymz1hb0000its6f5b1abw5","tag_id":"ckmrvj8ka0002g2827e1kcxmn","_id":"ckmymz1hf0002its6e4w62yda"},{"post_id":"ckmymz1hb0000its6f5b1abw5","tag_id":"ckmnglin0000519s69y5h05t4","_id":"ckmymz1hf0003its65ahqd5f8"}],"Tag":[{"name":"NoSQL","_id":"ckmnglin0000519s69y5h05t4"},{"name":"Database","_id":"ckmrvj8ka0002g2827e1kcxmn"},{"name":"Python","_id":"ckmrvyxle0006pw826ekgg13f"},{"name":"CS","_id":"ckmrvzuyz000apw82aak33ly9"},{"name":"面试","_id":"ckmtyu7kg0002tf82gl4xdfds"}]}}