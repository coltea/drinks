---
title: Redis面试题
date: 2021-03-24 11:49:11
tags: 
 - Database
 - NoSQL
categories: 
 - Redis
---
# Redis

#### 概述特性

- > **Redis为什么这么快？**

  1. Redis是单线程的，避免了多线程的上下文切换和并发控制开销；
  2. Redis大部分操作时基于内存，读写数据不需要磁盘I/O，所以速度非常快；
  3. Redis采用了I/O多路复用机制，提高了网络I/O并发性；
  4. Redis提供高效的数据结构，如跳跃表 o(logn) 、哈希表 o(1)等；



#### 数据结构

- **String** : 缓存、计数器、限速器、分布式锁、集群共享信息通用配置

- **List** : 消息队列、底层双向链表

- **Set** : 好友关系

- **zset(SortSet)** :排行榜

- **Hash** : 

- **Streams(流)** :

![img](https://static001.geekbang.org/resource/image/fb/f0/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg)



#### 业务场景

- **缓存** string

- **计数器** string

- **排行榜**  Zset

- **异步消息队列** List

- **分布式锁** string  EX seconds | PX milliseconds

- **共享信息、高频访问信息** 如session

- **集合关系** 好友关系  Set

  

#### 分布式锁

```shell
SET key value [EX seconds | PX milliseconds]  [NX]
```

分布式锁是由共享存储系统(redis就是其中一种)维护的变量，多个客户端可以向共享存储系统发送命令进行加锁或释放锁操作

- 加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；
- 锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；
- 锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。



#### 持久化策略

- **RDB**: 原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化。

  相对于大数据集，RDB的启动效率会更高。

- **AOF**: 原理是将Reids的操作日志以追加的方式写入文件。

  通常文件更大、恢复更慢、牺牲部分性能换取更高的缓存一致性



#### **架构模式**

- **主从**

  1对多，非高可用性

- **哨兵**

  监控从切换成主数据库，浪费资源

- **集群**

  分布式存储，至少需要三主三从



#### 数据淘汰机制

- volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
- volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰
- volatile-random 从已设置过期时间的数据集中任意选择数据淘汰
- allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰
- allkeys-random 从所有数据集中任意选择数据进行淘汰
- noeviction 禁止驱逐数据



#### 缓存

- **穿透**:空值设置一个较短的缓存
- **击穿**(业务狭隘):热门缓存失效
- **雪崩**:短时间内缓存大量失效  时间后加随机值



### 缓存

#### 缓存穿透

**概念：**当用户使用一个不存在的key进行查询时，缓存（redis）无法命中，需要访问数据库查询该数据，若数据库中没有数据，则不写入缓存（redis）中，这将导致不存在的数据每次请求都要去数据库查询，造成缓存穿透。

**解决办法：**

1. 使用布隆过滤器，通过bloomfilter.mightContain(key)来判断当前key是否命中。布隆过滤器原理：https://zhuanlan.zhihu.com/p/43263751
2. 当数据库查询结果为空时，在redis中将key对应的value设置空值，并设置一个较短的过期时间。





#### 缓存雪崩

缓存在同一时间内大量·键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。

解决方案：

1、也是像解决缓存穿透一样加锁排队，实现同上;

2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;